Iterable[E]:{ read .iter: lent Iter[mdf E] }

// The key here is all terminal operators go via fold.
Iter[E]:{
  mut .next: mut Opt[mdf E],
  mut .find(p: mut Predicate[mdf E]): mut Opt[mdf E] ->
    this.next.match{
      .none -> {},
      .some(e) -> p#e ? { .then -> Opt#e, .else -> this.find(p) },
      },

  mut .map[R](f: mut Mapper[mdf E, mdf R]): mut Iter[mdf R] -> {
    .next -> this.next.map{ a -> f#a },
    },
  mut .flatMap[R](f: mut Mapper[mdf E, mut Iter[mdf R]]): mut Iter[mdf R] -> fm={
    .next -> fm._next(this.map(f), {}),
    ._next(mapIter: mut Iter[mut Iter[mdf E]],
           curIter: Opt[mut Iter[mdf E]]): mut Opt[mdf E] ->
      curIter.match{
        .empty -> mapIter.next.match{
          .empty -> {},
          .some(nextIter) -> fm._next(mapIter, Opt#nextIter),
          },
        .some(curIter) -> curIter.next 
        }
    },
  mut .filter(p: mut Predicate[mdf E]): mut Iter[E] -> {
    .next -> this.next.find(p),
    },
  mut .scan[S,R](initial: mdf S, f: mut Scanner[mdf E, mdf R, mdf S]): mut Iter[mdf R] -> Let#{
    .var -> Ref#initial,
    .in(s) -> {
      .next -> this.next.match{ .none -> {}, .some(e) -> f#(s, e) },
      }
    },

  mut .fold[R](initial: mdf R, f: mut Folder[mdf E, mdf R]): mdf R ->
    this.next.match{
      .none -> initial,
      .some(e) -> this.fold(f#(initial, e), f),
      },
  mut .forEach(f: mut ForEacher[mdf E]): Void ->
    this.fold(Void, { (_, e) -> f#e }),
  mut .count: UNum -> this.fold(0u, { (acc, _) -> acc + 1u }),
  mut .toList: mut List[mdf E] -> Let#{
    .var -> List#,
    .in(res) -> Let#{
      .var -> iter.forEach({ e -> res.add(e) }),
      .in(_) -> res
      }
    }
}

Iter[UNum]:{
  mut .sum: UNum -> this.fold(0u, { (acc, e) -> acc + e }),
  }

ForEacher[E]:{ mut #(e: mdf E): Void }
Folder[E,R]:{ mut #(acc: mdf R, e: mdf E): mdf R }
Scanner[E,R,S]:{ mut #(state: mut Ref[mdf S], e: mdf E) }
Mapper[E,R]:{ mut #(e: mdf E): mdf R }
Predicate[E]:{ mut #(e: mdf E): Bool }
