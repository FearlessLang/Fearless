//shallow imm linked lists
//map handles elements in order

// Cons#(1, Cons#(2, Cons#(4, {})))
Cons:{
  #[E](h: E, t: LList[mdf E]): mut LList[mdf E]-> {
    .match(m) -> m.elem(this,e)
    },
  }
//alias mut LListMatch[recMdf E,mdf R,recMdf LList[recMdf E]] as _LListMatch
LList[E]:NoMutRead[E],Sealed,Iterable[recMdf E]{
  read .match[R](
    m: mut LListMatch[ recMdf E, mdf R, recMdf LList[recMdf E] ]
    ): mdf R -> m.empty,
  read .isEmpty: Bool -> this.match {
    .empty -> True,
    .elem(_,_) -> False
    },
  read .size: UNum -> this.match{
    .empty -> 0u,
    .elem(_,t) -> t.size+1u,
    },
  read ++(l1: recMdf LList[mdf E]): recMdf LList[mdf E] -> this.match{
    .empty -> l1,
    .elem(h, t) -> Cons#(h, t ++ l1)
    },
  read +(e: mdf E): recMdf LList[mdf E] -> this ++ Cons#(e, {}),
  read .get(i: UNum) : recMdf Opt[recMdf E] -> this.match{// or recMdf Opt[mdf E] depending on inference 
    .empty -> {},
    .elem(h, t) -> (i == 0) ? { .then -> Opt#h, .else -> t.get(i - 1u) }
    },
  read head: recMdf Opt[recMdf E] -> this.match{
    .empty -> {},
    .elem(h,_) -> Opt#h,
    },
  read tail: recMdf LList[mdf E] -> this.match{
    .empty -> {},
    .elem(_,t) -> t,
    },
  .iter -> iter={
    .next -> iter.cur.swap(iter.cur*.tail).head,
    mut .cur: mut Ref[recMdf LList[recMdf E]] -> Ref#this // can this conversion work?
    }
  }
LListMatch[E,L,R]:{ mut .elem(head: mdf E, tail: mdf L): mdf R, mut .empty: mdf R }

ListState[E]:NoMutRead[E],Sealed{
  read .size: UNum -> 0u,
  read .inner: recMdf LList[mdf E] -> {}
  }
ListState:{
  #[E](size: UNum, inner: mut LList[mdf E]): mut ListState[mdf E] -> {
    .size -> size,
    .inner -> inner
    }
  }
List[E]:NoMutRead[mdf E],Sealed,Iterable[recMdf E]{
  read .size: UNum,
  read .isEmpty: Bool,
  read .get(i: UNum): recMdf Opt[recMdf E],
  mut .add(e: mdf E): Void,
  mut .addAll(l1: recMdf List[mdf E]): Void,
  }
List{
  #[E]: mut List[mdf E] -> Let#[mut Ref[mut ListState[mdf E]]]{
    .var -> Ref#{},
    .in(s) -> list={ // capturing `mut Ref[mut ListState[mdf E]]`
      .size -> s*.size,
      .isEmpty -> s*.inner.isEmpty,
      .get(i) -> s*.inner.get(i),
      .iter -> iter={ // read .iter: mut Iter[mdf E]
        .next: Let#{
          .var -> iter.cur.swap(iter.cur* + 1u),
          .in(i) -> list.get(i)
          },
        mut .cur: mut Ref[UNum] -> Ref#0u,
      },
      .add(e) -> s := ListState#(s*.size + 1u, s*.inner + e),
      .addAll(l1) -> l1.iter.forEach{ e -> list.add(e) }
      }
    },
  }

------------------
Person:{ .name: mut Ref[Str], .age: mut Count[UNum] }
PersonK:{
  #(name: Ref[Str], age: Count[UNum]): mut Person -> {
    .name -> name,
    .age -> age,
    }
  }
Course:{
  .students: mut List[mut Person],
  mut addStudent(s: mut Person): Void -> this.students + s,
  read classSize(): UNum -> this.students.size
  }
CourseK:{
  #: Course -> Let#{
    .var -> Ref[mut List[mut Person]]#List#,
    .in(students) -> { students }
    }
  }
Main { Block
  .var{course = CourseK#}
  .do{ course.addStudent(Ref#"Nick", Count#u(22u)) }
  .do{ course.students.get(0).do{ s -> s.age++ } }
  }
