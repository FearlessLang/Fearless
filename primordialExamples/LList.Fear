//shallow imm linked lists
//map handles elements in order

// Cons#(1, Cons#(2, Cons#(4, {})))
Cons:{
  #[E](h: E, t: LList[mdf E]): mut LList[mdf E]-> {
    .match(m) -> m.elem(this,e)
    }
  }
//alias mut LListMatch[recMdf E,mdf R,recMdf LList[recMdf E]] as _LListMatch
LList[E]:NoMutRead[E],Sealed,Iterable[recMdf E]{
  read .match[R](
    m: mut LListMatch[ recMdf E, mdf R, recMdf LList[recMdf E] ]
    ): mdf R -> m.empty,
  read .isEmpty: Bool -> this.match {
    .empty -> True,
    .elem(_,_) -> False
    },
  read .size: UNum -> this.match{
    .empty -> 0u,
    .elem(_,t) -> t.size+1u,
    },
  read ++(l1: recMdf LList[mdf E]): recMdf LList[mdf E] -> this.match{
    .empty -> l1,
    .elem(h, t) -> Cons#(h, t ++ l1)
    },
  read +(e: mdf E): recMdf LList[mdf E] -> this ++ Cons#(e, {}),
  read .get(i: UNum) : recMdf Opt[recMdf E] -> this.match{// or recMdf Opt[mdf E] depending on inference 
    .empty -> {},
    .elem(h, t) -> (i == 0) ? { .then -> Opt#h, .else -> t.get(i - 1u) }
    },
  read head: recMdf Opt[recMdf E] -> this.match{
    .empty -> {},
    .elem(h,_) -> Opt#h,
    },
  read tail: recMdf LList[mdf E] -> this.match{
    .empty -> {},
    .elem(_,t) -> t,
    },
  .iter -> {
    .next -> self.cur.swap(self.cur* .tail).head,
    mut .cur: mut Ref[recMdf LList[recMdf E]] -> Ref#this
    }
  }
LListMatch[E,L,R]:{ mut .elem(head: mdf E, tail: mdf L): mdf R, mut .empty: mdf R }

ListState[E]:NoMutRead[E],Sealed{
  read .size: UNum -> 0u,
  read .inner: recMdf LList[mdf E] -> {}
  }
ListState:{
  #[E](size: UNum, inner: mut LList[mdf E]): mut ListState[mdf E] -> {
    .size -> size,
    .inner -> inner
    }
  }
List[E]:NoMutRead[mdf E],Sealed,Iterable[recMdf E]{
  read .size: UNum,
  read .isEmpty: Bool,
  read .get(i: UNum): recMdf Opt[recMdf E],
  mut .add(e: mdf E): Void,
  mut .addAll(l1: recMdf List[mdf E]): Void,
  }
List:{
  #[E]: mut List[mdf E] -> Let#[mut Ref[mut ListState[mdf E]]]{
    .var -> Ref#{},
    .in(s) -> { // capturing `mut Ref[mut ListState[mdf E]]`
      .size -> s*.size,
      .isEmpty -> s*.inner.isEmpty,
      .get(i) -> s*.inner.get(i),
      .iter -> {
        .next: Let#{
          .var -> self.cur.swap(self1.cur* + 1u),
          .in(i) -> self2.get(i)
          },
        mut .cur: mut Ref[UNum] -> Ref#0u,
      },
      .add(e) -> s := ListState#(s*.size + 1u, s*.inner + e),
      .addAll(l1) -> ?
      }
    }
  }

Iterable[E]:{ read iter: mut Iter[mdf E] }

Iter[E]:{
  mut .next: mut Opt[mdf E],
  mut .fold[B](initial: mdf B, f: mut Folder[mdf E, mdf B]): mdf B -> this.next.match{
    .none -> initial,
    .some(e) -> this.fold(f#(initial, e), f),
    },
  mut .forEach(f: mut ForEacher[mdf E]): Void ->
    this.fold(Void, { (_, e) -> f#e }),
  // TODO: this can be more generic
  mut .toList: mut List[mdf E] -> Let#{
    .var -> List#,
    .in(res) -> this.forEach({ e -> res.add(e) })
    },
}
ForEacher[A]:{ mut #(e: mdf A): Void }
Folder[A,B]:{ mut #(acc: mdf B, e: mdf A): mdf B }

------------------
LList[Num]+1

Person:{ .name: mut Ref[Str], .age: mut Ref[Num] }
Course:{
  .students: mut List[mut Person] -> List#,
  mut addStudent(s: mut Person): Void -> this.students + s,
  read classSize(): UNum -> this.students.size
}
// imagine some block syntax to do these statements
course.addStudent({ .name -> Ref#"Nick", .age -> Ref#22 })
course.students.get(0).do{ s -> s.age <- { age -> age + 1 } }
