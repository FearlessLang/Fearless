//shallow imm linked lists
//map handles elements in order
//match starts from the end and reaches the top

// Cons#(1, Cons#(2, Cons#(4, {})))
Cons:{
  #[E](h: E, t: LList[E]): mut LList[!E] -> { .match(m) -> m.elem(this,e) }
  }
LList[E]:Stores[E],Convertible,Sealed{
  read .match[R](m: mut LListMatch[!!E,!R,!!LList[!!E]]): !R -> m.empty,
  read .isEmpty: Bool -> this.match({ .empty -> True, .elem(_,_) -> False }),
  read .size: UNum -> this.match{
    .elem(_,t) -> t.size+1u,
    .empty -> 0u,
    },
  read ++(l1: !!List[!E]): !!LList[!E] -> this.match{
    .empty -> l1,
    .elem(h, t) -> Cons#(h, t ++ l1)
    },
  read +(e: !E): !!LList[!E] -> this ++ Cons#(e, {}),
  read .get(i: UNum) -> !!Opt[!!E] -> this.match{
    .empty -> {},
    .elem(h, t) -> (i == 0) ? { .then -> h, .else -> t.get(i - 1u) }
    },
  }
LListMatch[E,L,R]:{ mut .elem(head: !E, tail: !L): !R, mut .empty: !R }

ListState[E]:Stores[!E],Convertible,Sealed{
  read .size: Num -> 0u,
  read .inner: !!LList[!E] -> {},
  }
List[E]:Stores[!E],Convertible,Sealed{
  read .size: Num,
  read .isEmpty: Bool,
  read .get(i: UNum): !!Opt[!!E],
  mut +(e: !E): Void,
  mut ++(l1: !!List[!!E]): Void,
  }
List:{
  #[E]: mut List[!E] -> Let#[mut Ref[mut ListState[!E]]]{
    .var -> Ref#{},
    .in(s) -> { // capturing `mut Ref[mut ListState[!E]]`
      .size -> (s*).size,
      .isEmpty -> (s*).inner.isEmpty,
      .get(i) -> (s*).inner.get(i),
      +(e) -> s <- { old -> {
        .size -> old.size + 1u,
        .inner -> old.inner + e,
        }}
      }
    }
  }
------------------
LList[Num]+1

Person:{ .name: mut Ref[Str], .age: mut Ref[Num] }
Course:{
  .students: mut List[mut Person] -> List#,
  mut addStudent(s: mut Person): Void -> this.students + s,
  read classSize(): UNum -> this.students.size
}
// imagine some block syntax to do these statements
course.addStudent({ .name -> Ref#"Nick", .age -> Ref#22 })
course.students.get(0).do{ s -> s.age <- { age -> age + 1 } }
