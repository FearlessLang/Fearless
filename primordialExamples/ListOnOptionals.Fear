// List implemented with options (donâ€™t actually do this, more matching than needed.
// We can make list similar to optional with a Cons/Nil case for a better UX)

List[E]:NoMutRead[E]{
  read .get: mut Opt[recMdf E] -> {},
  read .cons: mut Opt[mut List[redMdf E]] -> {},   //tail
  }

User:{
  .emptyList: List[Num] -> {},
  .singleList: List[Num] -> { .get -> Opt#100 },
  .twoItems: List[Num] -> { .get -> Opt#100, cons: Opt#{ .get -> Opt#50 } },
  }