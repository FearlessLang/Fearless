Sealed:{}

Stores[X]:{}

Convertible:{}

Void:Sealed{}

Loop:{!:Void->this!}

HasIdentity:{ mut identityEq(other : read HasIdentity):Bool }//magic

Debug:Sealed{ #[T](x:T): T } // magic

F[R]:{ #:R }
F[A,R]:{ #(a:A):R }
F[A,B,R]:{ #(a:A,b:B):R }
F[A,B,C,R]:{ #(a:A,b:B,c:C):R }

s.map{}.filter{}.to List

Let:{
  #[V,R](l:Let[V,R]):R -> l.in(l.var)
  }
Let[V,R]:{
  .var:V,
  .in(v:V):R
  }
Cast:Sealed{ #[A](a:!A):mut Cast[!A]->{a} }
Cast[A]:Stores[A],Sealed{
  read .self:!!A
  read .as[R](c:CastId[!!A,!R]):!R->c.id(this.self)
  }
CastId[A,R]{ .id(a:!A):!R }

//Cast#(this).as[mut Bla]{x->x} //sugar ""this as[mut Bla]""
---------------

//usage of Let
Let#{.var->5, .in(x)->x+1}//six

//The example showing that we need convertible limitations
A[B]:{ f(b:B):Void }
imm A[Person] c = A[mut Person]:{ f(bob)->bob.name("Alice") }
c.f(immBob)


NEW IDEA FOR Convertible:
there is no explicit Convertible interface, the subtyping rules do soemething like below to check for
extra subtypes
//Convertible test:
A[mut X] is convertible to A[imm X] iff
  it would typecheck to use the adapter pattern to make
  MyA[X]:A[X]{
    inner:A[mut X]
    get(n)->this.inner.get(n)
    ...
    }
    
New Options for !! !
    recMdf mdf
    !!     !
    rec!   !

New name for Stores
NoMutRead[X]