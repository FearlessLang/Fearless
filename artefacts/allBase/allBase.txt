
//---File comparisons.fear
package base

Ordering: {
  .match[R](m: mut OrderingMatch[R]): R,
  }
FOrdering: {
  .less: Ordering -> {m -> m.less},
  .equal: Ordering -> {m -> m.equal},
  .greater: Ordering -> {m -> m.greater},
  }
OrderingMatch[R]: {
  mut .less: R,
  mut .equal: R,
  mut .greater: R,
  }

CompareInts: F[Int, Int, Ordering]{
  a, b -> Block#
    .if {a > b} .return {FOrdering.greater}
    .if {a < b} .return {FOrdering.less}
    .return {FOrdering.equal}
  }
CompareNats: F[Nat, Nat, Ordering]{
  a, b -> Block#
    .if {a > b} .return {FOrdering.greater}
    .if {a < b} .return {FOrdering.less}
    .return {FOrdering.equal}
  }
CompareFloats: F[Float, Float, Ordering]{
  a, b -> Block#
    .if {a > b} .return {FOrdering.greater}
    .if {a < b} .return {FOrdering.less}
    .return {FOrdering.equal}
  }

//---File optionals.fear
package base

Opts: {
  #[T](x: T): mut Opt[T] -> {.match(m) -> m.some(x)},
  }
Opt[T]: _Opt[T]{
  .match(m) -> m.empty,
  .map(f)   -> this.match(f),
  .flatMap(f)   -> this.match(f),
  ||(default)     -> this.match{.some(x) -> x, .empty -> default#},
  |(default)      -> this.match{.some(x) -> x, .empty -> default},
  !         -> this.match{.some(x) -> x, .empty -> Error.msg "Opt was empty"},
  .flow     -> this.match{.empty -> Flow#, .some(x) -> Flow#x},

  read .isEmpty: Bool -> this.match{.empty -> True,  .some(_)  -> False},
  read .isSome: Bool  -> this.match{.empty -> False, .some(_) -> True},
  imm .imm: Opt[imm T] -> this.match{.empty -> {}, .some(x) -> Opts#x},
  }
_Opt[T]: Sealed{ // Sealed because potential magic on .flow
  mut  .match[R:iso,imm,mut,mutH,read,readH](m: mut OptMatch[T, R]): R,
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut OptMatch[read/imm T, R]): R,
  imm  .match[R:iso,imm,mut,mutH,read,readH](m: mut OptMatch[imm T, R]): R,

  mut  .map[R](f: mut OptMap[T, R]):          mut Opt[R],
  read .map[R](f: mut OptMap[read/imm T, R]): mut Opt[R],
  imm  .map[R](f: mut OptMap[imm T, R]):      mut Opt[R],

  mut  .flatMap[R](f: mut OptFlatMap[T, R]):          mut Opt[R],
  read .flatMap[R](f: mut OptFlatMap[read/imm T, R]): mut Opt[R],
  imm  .flatMap[R](f: mut OptFlatMap[imm T, R]):      mut Opt[R],

  mut  ||(default: mut MF[T]):          T,
  read ||(default: mut MF[read/imm T]): read/imm T,
  imm  ||(default: mut MF[imm T]):      imm T,

  mut  |(default: T):          T,
  read |(default: read/imm T): read/imm T,
  imm  |(default: imm T):      imm T,

  mut  !: T,
  read !: read/imm T,
  imm  !: imm T,

  mut  .flow: mut Flow[T],
  read .flow: mut Flow[read/imm T],
  imm  .flow: mut Flow[imm T],
  }

OptMatch[T,R:iso,imm,mut,mutH,read,readH]:{ mut .some(x: T): R, mut .empty: R }
OptMap[T,R]:OptMatch[T, mut Opt[R]]{
  mut #(t: T): R,
  .some(x) -> Opts#(this#x),
  .empty -> {}
  }
OptFlatMap[T,R]:OptMatch[T, mut Opt[R]]{
  mut #(t: T): mut Opt[R],
  .some(x) -> this#x,
  .empty -> {}
  }

//---File lists.fear
package base

Collection: {
  read .size: Nat,
  read .isEmpty: Bool,
  }

LList:{ #[E]: mut LList[E] -> mut LList[E] }
LList[E]:Collection,Sealed{
  mut  .match[R](m: mut LListMatch[E, R]): R -> m.empty,
  read .match[R](m: mut LListMatchRead[E, R]): R -> m.empty,

  mut  .get(i: Nat): E -> Error.msg ("The index "+(i.str)+" is out of bounds for this list"),
  read .get(i: Nat): read/imm E -> Error.msg ("The index "+(i.str)+" is out of bounds for this list"),
  imm  .get(i: Nat): imm E -> Error.msg ("The index "+(i.str)+" is out of bounds for this list"),

  mut  .tryGet(i: Nat): mut Opt[E] -> {},
  read .tryGet(i: Nat): mut Opt[read/imm E] -> {},
  imm  .tryGet(i: Nat): mut Opt[imm E] -> {},

  mut  .head: mut Opt[E] -> {},
  read .head: mut Opt[read/imm E] -> {},
  imm  .head: mut Opt[imm E] -> {},

  mut  .tail: mut LList[E] -> this,
  read .tail: read LList[E] -> this,
  imm  .tail: LList[E] -> this,

  mut  ++(l1: mut LList[E]): mut LList[E] -> l1,
  read ++(l1: read LList[read E]): read LList[read E] -> l1,
  imm ++(l1: LList[imm E]): LList[imm E] -> l1,

  mut  +(e: E): mut LList[E] -> this ++ (mut LList[E].pushFront[](e)),
  read +(e: read E): read LList[read E] -> this ++ (read LList[read E].pushFront[](e)),
  imm  +(e: imm E): LList[imm E] -> this ++ (LList[imm E].pushFront[](e)),

  mut .iter: mut Iter[E] -> Block#
    .let[mut Var[mut LList[E]]] cursor = {Vars#(this)}
    .return {{.next -> cursor.swap(cursor.get.tail).head}},
  imm .iter: mut Iter[imm E] -> Block#
    .let[mut Var[LList[E]]] cursor = {Vars#(this)}
    .return {{.next -> cursor.swap(cursor.get.tail).head}},
  read .iter: mut Iter[read/imm E] -> Block#
    .let[mut Var[read LList[E]]] cursor = {Vars#(this)}
    .return {{.next -> cursor.swap(cursor.get.tail).head}},

  mut  .flow: mut Flow[E] -> Block#
    .let cursor = {Vars#this}
    .return {Flow.fromOp({'op
      .stop -> cursor := {},
      .isRunning -> cursor*.isEmpty.not,
      .step(downstream) -> Block#
        .let cursor' = {cursor.swap(cursor*.tail)}
        .do {cursor'.head.match{
          .some(x) -> Block#
            .do {downstream#x}
            .if {cursor.get.isEmpty} .do {Block#(downstream.stop, op.stop)}
            .return {Void},
          .empty -> Block#(downstream.stop, op.stop),
          }}
        .return {{}},
      }, this.size)},
  read .flow: mut Flow[read/imm E] -> Flow.fromOp[read/imm E](this._flowread, this.size),
  read ._flowread: mut FlowOp[read/imm E] -> Block#
    .let cursor = {Vars#this}
    .return {mut FlowOp[read/imm E]{'op
      .stop -> cursor := {},
      .isRunning -> cursor*.isEmpty.not,
      .step(downstream) -> Block#
        .let cursor' = {cursor.swap(cursor*.tail)}
        .do {cursor'.head.match{
          .some(x) -> Block#
            .do {downstream#x}
            .if {cursor.get.isEmpty} .do {Block#(downstream.stop, op.stop)}
            .return {Void},
          .empty -> Block#(downstream.stop, op.stop),
          }}
        .return {{}},
      }},
  imm  .flow: mut Flow[imm E] -> Flow.fromOp[imm E](this._flowimm, this.size),
  imm  ._flowimm: mut FlowOp[imm E] -> Block#
    .let cursor = {Vars#this}
    .return {mut FlowOp[imm E]{'op
      .stop -> cursor := {},
      .isRunning -> cursor*.isEmpty.not,
      .step(downstream) -> Block#
        .let cursor' = {cursor.swap(cursor*.tail)}
        .do {cursor'.head.match{
          .some(x) -> Block#
            .do {downstream#x}
            .if {cursor.get.isEmpty} .do {Block#(downstream.stop, op.stop)}
            .return {Void},
          .empty -> Block#(downstream.stop, op.stop),
          }}
        .return {{}},
      }},

  read .isEmpty: Bool -> True,
  read .size: Nat -> 0,

  mut .list: mut List[E] -> List.fromLList[E](this),

  mut .pushFront(e: E): mut LList[E] -> Let#{
    .var -> this.size + 1,
    .in(len) -> {'l
      mut  .match[R](m: mut LListMatch[E, R]): R -> m.elem(e, this),
      read .match[R](m: mut LListMatchRead[E, R]): R -> m.elem(e, this),
      imm  .match[R](m: mut LListMatchRead[E, R]): R -> m.elem(e, this),

      mut  .get(i: Nat): E -> (i == 0) ? { .then -> e, .else -> this.get[](i - 1) },
      read .get(i: Nat): read/imm E -> (i == 0) ?[read/imm E] { .then -> e, .else -> this.get[](i - 1) },
      imm  .get(i: Nat): imm E -> (i  == 0) ?[imm E] { .then -> e, .else -> this.get[](i - 1) },

      mut  .tryGet(i: Nat): mut Opt[E] -> (i == 0) ? { .then -> Opts#e, .else -> this.tryGet(i - 1) },
      read .tryGet(i: Nat): mut Opt[read/imm E] -> (i == 0) ? { .then -> Opts#[read/imm E]e, .else -> this.tryGet(i - 1) },
      imm  .tryGet(i: Nat): mut Opt[imm E] -> (i  == 0) ? { .then -> Opts#[imm E]e, .else -> this.tryGet(i - 1) },

      mut  .head: mut Opt[E] -> Opts#e,
      read .head: mut Opt[read/imm E] -> Opts#[read/imm E]e,
      imm  .head: mut Opt[imm E] -> Opts#[imm E]e,

      .tail -> this,
      ++(l1) -> (this ++ l1).pushFront(e),
      .isEmpty -> False,
      .size -> len,
      }
    },
  read .pushFront(e: E): read LList[E] -> Let#{
    .var -> this.size + 1,
    .in(len) -> {'l
      read .match[R](m: mut LListMatchRead[E, R]): R -> m.elem(e, this),
      imm  .match[R](m: mut LListMatchRead[E, R]): R -> m.elem(e, this),

      read .get(i: Nat): read/imm E -> (i == 0) ?[read/imm E] { .then -> e, .else -> this.get(i - 1) },
      imm  .get(i: Nat): imm E -> (i  == 0) ?[imm E] { .then -> e, .else -> this.get(i - 1) },

      read .tryGet(i: Nat): mut Opt[read/imm E] -> (i == 0) ? { .then -> Opts#[read/imm E]e, .else -> this.tryGet(i - 1) },
      imm  .tryGet(i: Nat): mut Opt[imm E] -> (i  == 0) ? { .then -> Opts#[imm E]e, .else -> this.tryGet(i - 1) },

      read .head: mut Opt[read/imm E] -> Opts#[read/imm E]e,
      imm  .head: mut Opt[imm E] -> Opts#[imm E]e,
      .tail -> this,
      ++(l1) -> (this ++ l1).pushFront(e),
      .isEmpty -> False,
      .size -> len,
      }
    },
  }
LListMatch[E,R]: {
  mut .elem(head: E, tail: mut LList[E]): R,
  mut .empty: R,
  }
LListMatchRead[E,R]: {
  mut .elem(head: read/imm E, tail: read LList[E]): R,
  mut .empty: R,
  }

List: Sealed{
  #[E]: mut List[E] -> Magic!,
  #[E](e1: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E, e11: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E, e11: E, e12: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E, e11: E, e12: E, e13: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E, e11: E, e12: E, e13: E, e14: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E, e11: E, e12: E, e13: E, e14: E, e15: E): mut List[E] -> Magic!,
  #[E](e1: E, e2: E, e3: E, e4: E, e5: E, e6: E, e7: E, e8: E, e9: E, e10: E, e11: E, e12: E, e13: E, e14: E, e15: E, e16: E): mut List[E] -> Magic!,
  .fromLList[E](list: mut LList[E]): mut List[E] -> Magic!,
  .withCapacity[E](capacity: Nat): mut List[E] -> Magic!,
  }
List[E]: Collection,Sealed{
  mut  .get(i: Nat): E,
  read .get(i: Nat): read/imm E,
  imm  .get(i: Nat): imm E,

  mut  .tryGet(i: Nat): mut Opt[E],
  read .tryGet(i: Nat): mut Opt[read/imm E],
  imm  .tryGet(i: Nat): mut Opt[imm E],

  mut .add(e: E): Void,
  mut +(e: E): mut List[E] -> Block#(this.add(e), this),
  mut .addAll(other: mut List[E]): Void -> other.iter.for{e -> this.add(e)},

  mut .clear: Void,

  mut  ==(eq: read F[E, E, Bool], other: mut List[E]): Bool ->
    this.size == (other.size)
    && {this.flow
      .with(other.flow)
      .all{ab -> eq#(ab.a, ab.b)}
      },
  read ==(eq: read F[read/imm E, read/imm E, Bool], other: read List[E]): Bool ->
    this.size == (other.size)
    && {this.flow
      .with(other.flow)
      .all{ab -> eq#(ab.a, ab.b)}
      },
  imm  ==(eq: F[imm E, imm E, Bool], other: List[E]): Bool ->
    this.size == (other.size)
    && {this.flow
      .with(other.flow)
      .all{ab -> eq#(ab.a, ab.b)}
      },

  mut .flow: mut Flow[E] -> Block#
    .let[mut Count[Nat]] cursor = {Count.nat(0)}
    .return {Flow.fromMutSource({'self
      .isRunning -> cursor* < (this.size),
      .stop -> cursor := (this.size),
      .step(downstream) -> this.tryGet(cursor++).match{
        .some(x) -> Block#
          .do {downstream#x}
          .if {cursor.get >= (this.size)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .empty -> Block#(downstream.stop, self.stop),
        },
        .for(downstream) -> Block#
          .loop {Block#
            .if {cursor.get >= (this.size)} .return {Block#(downstream.stop, self.stop, ControlFlow.break)}
            .do {downstream#(this.get(cursor++))}
            .return {ControlFlow.continue}
            }.return {{}},
      }, this.size)},
  read .flow: mut Flow[read/imm E] -> Flow.fromOp(this._flowread(0, this.size), this.size),
  read ._flowread(start: Nat, end: Nat): mut FlowOp[read/imm E] -> Block#
    .let[mut Count[Nat]] cursor = {Count.nat(start)}
    .let[mut Count[Nat]] endCursor = {Count.nat(end)}
    .return {{'self
      .isRunning -> cursor* < (endCursor.get),
      .stop -> cursor := (endCursor.get),
      .step(downstream) -> cursor.get < (endCursor.get) ? {
        .then -> Block#
          .do {downstream#(this.get(cursor++))}
          .if {cursor.get >= (endCursor.get)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .else -> Block#(downstream.stop, self.stop),
        },
      .for(downstream) -> Block#
        .loop {Block#
          .if {cursor.get >= (endCursor.get)} .return {Block#(downstream.stop, self.stop, ControlFlow.break)}
          .do {downstream#(this.get(cursor++))}
          .return {ControlFlow.continue}
          }.return {{}},
      .split -> self.canSplit ? {
        .else -> {},
        .then -> Block#
          .let cur = {cursor.get}
          .let[Nat] mid = {cur + ((endCursor.get - cur) / 2)}
          .let[Nat] end' = {endCursor.swap(mid)}
          .return {Opts#(this._flowread(mid, end'))},
        },
      .canSplit -> endCursor.get - (cursor.get) > 1,
      }},
  imm .flow: mut Flow[imm E] -> Flow.fromOp(this._flowimm(0, this.size), this.size),
  imm ._flowimm(start: Nat, end: Nat): mut FlowOp[imm E] -> Block#
    .let[mut Count[Nat]] cursor = {Count.nat(start)}
    .let[mut Count[Nat]] endCursor = {Count.nat(end)}
    .return {{'self
      .isRunning -> cursor* < (endCursor.get),
      .stop -> cursor := (endCursor.get),
      .step(downstream) -> cursor.get < (endCursor.get) ? {
        .then -> Block#
          .do {downstream#(this.get(cursor++))}
          .if {cursor.get >= (endCursor.get)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .else -> Block#(downstream.stop, self.stop),
        },
      .for(downstream) -> Block#
        .loop {Block#
          .if {cursor.get >= (endCursor.get)} .return {Block#(downstream.stop, self.stop, ControlFlow.break)}
          .do {downstream#(this.get(cursor++))}
          .return {ControlFlow.continue}
          }.return {{}},
      .split -> self.canSplit ? {
        .else -> {},
        .then -> Block#
          .let cur = {cursor.get}
          .let[Nat] mid = {cur + ((endCursor.get - cur) / 2)}
          .let[Nat] end' = {endCursor.swap(mid)}
          .return {Opts#(this._flowimm(mid, end'))},
        },
      .canSplit -> endCursor.get - (cursor.get) > 1,
      }},

  mut .iter: mut Iter[E] -> Let#{
    .var -> Count.nat(0),
    .in(cursor) -> { .next -> this.tryGet(cursor++) }
    },
  read .iter: mut Iter[read/imm E] -> Let#{
    .var -> Count.nat(0),
    .in(cursor) -> { .next -> this.tryGet(cursor++) }
    },
  imm .iter: mut Iter[imm E] -> Let#{
    .var -> Count.nat(0),
    .in(cursor) -> { .next -> this.tryGet(cursor++) }
    },
  }

ListView[E]: List[E]{
  read .inner: read List[E],
  read .expose(list: mut List[E], i: Nat): E,
  read .tryExpose(list: mut List[E], i: Nat): mut Opt[E],
  }
ListViews: {
  .subList[E](list: read List[E], from: Nat, to: Nat): read ListView[E] -> Block#
    .assert({from <= to}, "Invalid range for the list proxy, "+(from.str)+" is greater than "+(to.str))
    .assert({to <= (list.size)}, "Invalid range for the list proxy, "+(to.str)+" is greater than the list size ("+(list.size.str)+")")
    .return {{'self
      .inner -> list,
      .size -> to - from,
      .isEmpty -> self.size == 0,
      .expose(rawList, i) -> i < (self.size) ? {
        .then -> rawList.get(from + i),
        .else -> Error.msg("Index "+(i.str)+" is out of bounds for this list")
        },
      .tryExpose(rawList, i) -> i < (self.size) ? {
        .then -> rawList.tryGet(from + i),
        .else -> {}
        },
      read .get(i: Nat): read/imm E -> i < (self.size) ? {
        .then -> list.get(from + i),
        .else -> Error.msg("Index "+(i.str)+" is out of bounds for this list")
        },
      imm  .get(i: Nat): imm E -> i < (self.size) ? {
        .then -> list.get(from + i),
        .else -> Error.msg("Index "+(i.str)+" is out of bounds for this list")
        },
      read .tryGet(i: Nat): mut Opt[read/imm E] -> i < (self.size) ? {
        .then -> list.tryGet(from + i),
        .else -> {}
        },
      imm  .tryGet(i: Nat): mut Opt[imm E] -> i < (self.size) ? {
        .then -> list.tryGet(from + i),
        .else -> {}
        },
      }},

  .indexMap[E](list: read List[E], mappings: List[Nat]): read ListView[E] -> Block#
    .assert({mappings.size == (list.size)}, "The mappings list must be the same size as the original list ("+(mappings.size.str)+" vs. "+(list.size.str)+")")
    .return {{'self
      .inner -> list,
      .size -> list.size,
      .isEmpty -> list.isEmpty,
      .expose(rawList, i) -> Assert!(
        rawList.size == (mappings.size), "The provided list must be the same size as the list this is proxying ("+(rawList.size.str)+" vs. "+(mappings.size.str)+")",
        {rawList.get(mappings.get(i))}
        ),
      .tryExpose(rawList, i) -> mappings.tryGet(i).flatMap{i' -> rawList.tryGet(i')},
      .get(i) -> list.get(mappings.get(i)),
      read .tryGet(i: Nat): mut Opt[read/imm E] -> mappings.tryGet(i).flatMap{i' -> list.tryGet(i')},
      imm  .tryGet(i: Nat): mut Opt[imm E] -> mappings.tryGet(i).flatMap{i' -> list.tryGet(i')},
      }},
  }

//---File pkg.fear
package base
alias base.iter.Iter as Iter,
alias base.json.Json as Json,
alias base.json.Jsons as Jsons,

//---File strings.fear
package base
Str: Sealed,Stringable,base.flows.Joinable[Str],ToHash{
  read .isEmpty: Bool,
  .size: Nat,
  +(other: read Stringable): Str,
  ==(other: Str): Bool,
  !=(other: Str): Bool,
  .startsWith(other: Str): Bool,
  .assertEq(other: Str): Void,
  .assertEq(message: Str, other: Str): Void,
  .substring(start: Nat, end: Nat): Str,
  .charAt(index: Nat): Str,
  .normalise: Str,
  mut .append(other: read Stringable): Void,
  mut +(other: read Stringable): mut Str,
  mut .clear: Void,
  .flow: mut Flow[Str],

  .float: mut Action[Float],
  .utf8: List[Byte],
  }

Stringable: {
  read .str: Str,
  }

UTF16: Sealed{
  .fromCodePoint(codePoint: Nat): Str -> Magic!,
  .isSurrogate(codePoint: Nat): Bool -> codePoint >= 55296 & (codePoint < 57344),
  .fromSurrogatePair(high: Nat, low: Nat): Str -> Magic!,
  }

UTF8: Sealed{
  .fromBytes(utf8Bytes: read List[Byte]): mut Action[Str] -> Magic!,
  }

AtomiseStr: {
  #(raw: Str): mut Flow[Str] -> raw.utf8.flow
    .actor[mut List[Byte], Str](List#, {downstream, buffer, byte -> Block#
      .do {buffer.add(byte)}
      .return {UTF8.fromBytes(buffer).run{
        .ok(str) -> Block#(buffer.clear, downstream#str, {}),
        .info(_) -> {},
        }}
      }),
  }

SimpleStr: Str

StrMap[V]: LinkedLens[Str, V]{k1, k2 -> k1 == k2}

_StrInstance: Str{
  .size -> Magic!,
  .isEmpty -> Magic!,
  +(other) -> Magic!,
  ==(other) -> Magic!,
  !=(other) -> Magic!,
  .startsWith(other) -> Magic!,
  .assertEq(other) -> Magic!,
  .assertEq(other, message) -> Magic!,
  .str -> Magic!,
  .substring(_,_) -> Magic!,
  .charAt(_) -> Magic!,
  .normalise -> Magic!,
  .append(_) -> Magic!,
  .clear -> Magic!,
  .flow -> Magic!,
  .join(_) -> Magic!,
  .hash(h) -> Magic!,
  .float -> Magic!,
  .utf8 -> Magic!,
  }

_StrHelpers: {
  .assertEq(expected: Str, actual: Str): Void ->
    Assert!(expected == actual, "Expected: "+expected+"\nActual: "+actual, {{}}),
  .assertEq(expected: Str, actual: Str, message: Str): Void ->
    Assert!(expected == actual, message+"\nExpected: "+expected+"\nActual: "+actual, {{}}),
  }

//---File results.fear
package base

Res:{
  #[T](x: T): mut Res[T] -> { .match(m) -> m.a(x), },
  .ok[T,E](x: T): mut Res[T, E] -> { .match(m) -> m.a(x), },
  .err[T,E](x: E): mut Res[T, E] -> { .match(m) -> m.b(x), },
  }
Res[T]:Res[T, Info]
Res[T,E]:Either[T, E]{
  mut  .resMatch[R:iso,imm,mut,mutH,read,readH](m: mut ResMatch[T, E, R]): R -> this.match(m),
  read .resMatch[R:iso,imm,mut,mutH,read,readH](m: mut ResMatch[read T, read E, R]): R -> this.match(m),
  imm  .resMatch[R:iso,imm,mut,mutH,read,readH](m: mut ResMatch[imm T, imm E, R]): R -> this.match(m),

  mut  !: T -> this.resMatch[T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },
  read !: read T -> this.resMatch[read T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },
  imm  !: imm T -> this.resMatch[imm T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },

  mut  .map[R](f: mut ResMap[T, E, R]): mut Res[R, E] -> this.match(f),
  read .map[R](f: mut ResMap[read T, read E, R]): mut Res[R, read E] -> this.match(f),
  imm  .map[R](f: mut ResMap[imm T, imm E, R]): mut Res[R, imm E] -> this.match(f),

  mut  .mapErr[R](f: mut ResMapErr[T, E, R]): mut Res[T, R] -> this.match(f),
  read .mapErr[R](f: mut ResMapErr[read T, read E, R]): mut Res[read T, R] -> this.match(f),
  imm  .mapErr[R](f: mut ResMapErr[imm T, imm E, R]): mut Res[imm T, R] -> this.match(f),

  mut  .ok: mut Opt[T] -> this.resMatch{ .ok(x) -> Opts#x, .err(_) -> {} },
  read .ok: mut Opt[read T] -> this.resMatch{ .ok(x) -> Opts#x, .err(_) -> {} },
  imm  .ok: iso Opt[imm T] -> this.resMatch{ .ok(x) -> Opts#x, .err(_) -> {} },

  mut  .err: mut Opt[E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opts#e },
  read .err: mut Opt[read E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opts#e },
  imm  .err: iso Opt[imm E] -> this.resMatch[mut Opt[imm E]]{ .ok(_) -> {}, .err(e) -> Opts#e },

  read .isErr: Bool -> this.resMatch{ .err(_) -> True, .ok(_) -> False },
  read .isOk: Bool -> this.resMatch{ .err(_) -> False, .ok(_) -> True },
  }

ResMatch[T,E,R:iso,imm,mut,mutH,read,readH]:EitherMatch[T, E, R]{
  .a(x) -> this.ok(x), .b(x) -> this.err(x),
  mut .ok(x: T): R,
  mut .err(x: E): R
  }
ResMap[T,E,R]:ResMatch[T, E, mut Res[R, E]]{
  mut #(x: T): R,
  .ok(x) -> Res.ok[R, E](this#x),
  .err(x) -> Res.err[R, E](x),
  }
ResMapErr[T,E,R]:ResMatch[T, E, mut Res[T, R]]{
  mut #(x: E): R,
  .ok(x) -> Res.ok[T, R](x),
  .err(x) -> Res.err[T, R](this#x),
  }

//---File hash.fear
package base

ToHash: {
  read .hash(hasher: mut Hasher): mut Hasher,
  }

Hasher: {
  mut .compute: Nat,

  mut .nat(x: read Nat): mut Hasher,
  mut .int(x: read Int): mut Hasher,
  mut .float(x: read Float): mut Hasher,
  mut .byte(x: read Byte): mut Hasher,
  mut .str(x: read Str): mut Hasher,
  mut .hash(x: read ToHash): mut Hasher -> x.hash(this),
  }

CheapHash: Hasher{
  .compute -> Magic!,
  .nat(x) -> Magic!,
  .int(x) -> Magic!,
  .float(x) -> Magic!,
  .byte(x) -> Magic!,
  .str(x) -> Magic!,
  }

//---File maps.fear
package base

Map[K:imm,V]: {
  read .keyEq(k1: K, k2: K): Bool,
  imm  .get(k: K): mut Opt[imm V] -> {},
  read .get(k: K): mut Opt[read/imm V] -> {},
  read .isEmpty: Bool -> True,
  }

EmptyMap[K:imm,V]: Map[K,V]{
  .keyEq(k1, k2) -> False,
  .get(k) -> {},
  }

Maps: Sealed{
  .hashMap[K:imm,V](keyEq: read F[K,K,Bool], hash: F[K,read ToHash]): mut LinkedHashMap[K,V] -> Magic!,
  }
LinkedHashMap[K:imm,V]: Map[K,V]{
  mut  .get(k: K): mut Opt[V],
  imm  .get(k: K): mut Opt[imm V],
  read .get(k: K): mut Opt[read/imm V],

  mut .remove(k: K): mut Opt[V],
  mut .clear: Void,
  mut +(k: K, v: V): mut LinkedHashMap[K,V],
  mut .put(k: K, v: V): Void -> Block#(this + (k,v)),

  read .keys: mut Flow[imm K],

  mut  .values: mut Flow[V],
  imm  .values: mut Flow[imm V],
  read .values: mut Flow[read/imm V],

  mut  .flowMut: mut Flow[mut Entry[K,V]],
  imm  .flow: mut Flow[imm Entry[K,V]],
  read .flow: mut Flow[read Entry[K,V]],
  }
Entry[K:imm,V]: {
  read .key: K,
  mut  .value: V,
  read .value: read/imm V,
  }

Lens[K: imm, V]:Map[K, imm V]{
  .put(k: K, v: imm V): mut Lens[K, V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opts#v, .else -> this.get(k')},
    read .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opts#v, .else -> this.get(k')},
    .isEmpty -> False,
    },
  .map[R](f: MapMapImm[K, imm V, imm R]): Lens[K, imm R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] -> this.get(k).map{res -> f#(k, res)},
    read .get(k: K): mut Opt[imm R] -> this.get(k).map{res -> f#(k, res)},
    .isEmpty -> this.isEmpty,
    },
  }

LinkedLens[K:imm, V]:Map[K, V]{
  imm  .get(k: K): mut Opt[imm V] -> {},
  mut  .get(k: K): mut Opt[V] -> {},
  read .get(k: K): mut Opt[read/imm V] -> {},

  imm  .put(k: K, v: imm V): imm LinkedLens[K, V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opts#[imm V]v, .else -> this.get(k')},
    read .get(k': K): mut Opt[read/imm V] -> next.keyEq(k, k') ? {
      .then -> Opts#[read/imm V]v,
      .else -> this.get(k').match{.some(v') -> Opts#[read/imm V]v', .empty -> mut Opt[read/imm V]},
      },
    .isEmpty -> False,
    },
  mut  .put(k: K, v: V): mut LinkedLens[K, V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opts#[imm V]v, .else -> this.get(k')},
    mut  .get(k': K): mut Opt[V] -> next.keyEq(k, k') ? {.then -> Opts#v, .else -> this.get(k')},
    read .get(k': K): mut Opt[read/imm V] -> next.keyEq(k, k') ? {.then -> Opts#[read/imm V]v, .else -> this.get(k')},
    .isEmpty -> False,
    },
  read .put(k: K, v: V): read LinkedLens[K, V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opts#[imm V]v, .else -> this.get(k')},
    read .get(k': K): mut Opt[read/imm V] -> next.keyEq(k, k') ? {.then -> Opts#[read/imm V]v, .else -> this.get(k')},
    .isEmpty -> False,
    },

  imm .map[R](fImm: MapMapImm[K, imm V, imm R], fRead: MapMapRead[K, V, R]): LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    read .get(k: K): mut Opt[read/imm R] -> this.get(k).map{res -> fRead#(k, res)},
    .isEmpty -> this.isEmpty,
    },
  mut .map[R](fImm: MapMapImm[K, imm V, imm R], fMut: mut MapMapMut[K, V, R], fRead: read MapMapRead[K, V, R]): mut LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    mut  .get(k: K): mut Opt[R] ->      this.get(k).map{res -> fMut#(k, res)},
    read .get(k: K): mut Opt[read/imm R] -> this.get(k).map mut OptMap[read/imm V, read/imm R]{res -> fRead#(k, res)},
    .isEmpty -> this.isEmpty,
    },
  read .map[R](fImm: MapMapImm[K, imm V, imm R], fRead: read MapMapRead[K, V, R]): read LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    read .get(k: K): mut Opt[read/imm R] -> this.get(k).map{res -> fRead#(k, res)},
    .isEmpty -> this.isEmpty,
    },
  }

MapMapImm[K:imm,V,R]:{ #(k: K, v: imm V): R }
MapMapMut[K:imm,V,R]:{ mut #(k: K, v: V): R }
MapMapRead[K:imm,V,R]:{ read #(k: K, v: read/imm V): R }

//---File actions.fear
package base


Actions: {
  .lazy[T](f: mut MF[T]): mut Action[T] -> {m -> m.ok(f#)},
  .ok[T](x: T): mut Action[T] -> {m -> m.ok(x)},
  .info[T](info: Info): mut Action[T] -> {m -> m.info(info)},
  }
Action[T]: {
  mut .run[R](m: mut ActionMatch[T,R]): R,
  mut .map[R](f: mut MF[T,R]): mut Action[R] -> {m -> this.run{
    .ok(x) -> m.ok(f#x),
    .info(i) -> m.info(i),
    }},
  mut .andThen[R](f: mut MF[T,mut Action[R]]): mut Action[R] -> {m -> this.run{
    .ok(x) -> f#x.run(m),
    .info(i) -> m.info(i),
    }},
  mut .mapInfo(f: mut MF[Info,Info]): mut Action[T] -> {m -> this.run{
    .ok(x) -> m.ok(x),
    .info(i) -> m.info(f#i),
    }},
  mut !: T -> this.run{.ok(x) -> x, .info(i) -> Error!i},
  mut .ok: mut Opt[T] -> this.run{.ok(x) -> Opts#x, .info(_) -> {}},
  mut .info: Opt[Info] -> this.run{.ok(_) -> {}, .info(i) -> Opts#i},
  }
ActionMatch[T,R]: {
  mut .ok(x: T): R,
  mut .info(info: Info): R,
  }

//---File json/pkg.fear
package base.json
alias base.iter.Iter as Iter,

alias base.IsoPod as IsoPod,

alias base.caps.Write as Write,
alias base.caps.Read as Read,
alias base.caps.FileHandleMode as FileHandleMode,
alias base.caps.Create as Create,

alias base.caps.UnrestrictedIO as UnrestrictedIO,
alias base.caps.IO as IO,
alias base.caps.Env as Env,
alias base.caps.FEnv as FEnv,
alias base.caps.FRandomSeed as FRandomSeed,
alias base.caps.RandomSeed as RandomSeed,

alias base.caps.System as System,

alias base.Res as Res,

alias base.LinkedLens as LinkedLens,
alias base.Map as Map,
alias base.EmptyMap as EmptyMap,
alias base.Lens as Lens,

alias base.Extensible as Extensible,
alias base.Extension as Extension,

alias base.Either as Either,

alias base.Block as Block,

alias base.Str as Str,
alias base.StrMap as StrMap,
alias base.Stringable as Stringable,

alias base.Var as Var,
alias base.Count as Count,
alias base.VarImm as VarImm,

alias base.Opt as Opt,
alias base.Opts as Opts,

alias base.Int as Int,
alias base.Float as Float,
alias base.Nat as Nat,
alias base.Byte as Byte,

alias base.LList as LList,
alias base.List as List,
alias base.ListViews as ListViews,
alias base.Collection as Collection,

alias base.As as As,
alias base.Box as Box,
alias base.Sealed as Sealed,
alias base.Magic as Magic,
alias base.F as F,
alias base.MF as MF,
alias base.Consumer as Consumer,
alias base.Let as Let,
alias base.Void as Void,
alias base.HasIdentity as HasIdentity,

alias base.Ice as Ice,
alias base.Freezer as Freezer,
alias base.ToImm as ToImm,

alias base.Abort as Abort,
alias base.Main as Main,

alias base.Error as Error,
alias base.Try as Try,
alias base.Info as Info,
alias base.Infos as Infos,

alias base.Bool as Bool,
alias base.True as True,
alias base.False as False,

alias base.Assert as Assert,

alias base.flows.Flow as Flow,
alias base.flows.ActorRes as ActorRes,
alias base.flows.ActorImpl as Actor,
alias base.flows._ActorSink as Sink,

alias base.Ordering as Ordering,
alias base.FOrdering as FOrdering,

alias base.Regexs as Regexs,
alias base.Regex as Regex,

alias base.UTF16 as UTF16,
alias base.UTF8 as UTF8,

alias base.Actions as Actions,
alias base.Action as Action,

alias base.Maps as Maps,
alias base.LinkedHashMap as LinkedHashMap,

alias base.AtomiseStr as AtomiseStr,

//---File json/json.fear
package base.json

alias base.Todo as Todo,

JsonMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .string(s: Str): R,
  mut .number(n: Float): R,
  mut .bool(b: Bool): R,
  mut .object(o: LinkedHashMap[Str,Json]): R,
  mut .array(a: List[Json]): R,
  mut .null: R,
  }
Jsons: {
  .string(s: Str): Json -> {m -> m.string(s)},
  .number(n: Float): Json -> {m -> m.number(n)},
  .bool(b: Bool): Json -> {m -> m.bool(b)},
  .object(o: LinkedHashMap[Str, Json]): Json -> {m -> m.object(o)},
  .array(a: List[Json]): Json -> {m -> m.array(a)},
  .null: Json -> {m -> m.null},
  }
Json: {
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut JsonMatch[R]): R,
  .str: Str -> _JsonToStr#this,
  }

_JsonToStr: {
  #(json: Json): Str -> json.match{
    .string(s) -> mut "\"" + (this.escape(s)) + "\"",
    .number(n) -> n.str,
    .bool(b)   -> b ? {.then -> "true", .else -> "false"},
    .object(o) -> "{"+(this.object(o))+"}",
    .array(a)  -> "["+(this.array(a))+"]",
    .null      -> "null",
    },

  .array(a: List[Json]): Str -> a.flow
    .map{json->this#json}
    .join ", ",
  .object(o: LinkedHashMap[Str,Json]): Str -> o.flow
    .map[Str]{kv -> mut "\""+(this.escape(kv.key))+"\": " + (this#(kv.value))}
    .join ", ",
  .escape(s: Str): Str -> Block#
    .let[Regex] mustEscape = {Regexs#"[\\U{0000}-\\U{001F}]"} // unicode control characters
    .return {AtomiseStr#s
      .map{ch -> Block#
        .if {ch == "\u005C"} .return {"\\"}
        .if {ch == "\n"} .return {"\\n"}
        .if {ch == "\b"} .return {"\\b"}
        .if {ch == "\f"} .return {"\\f"}
        .if {ch == "\n"} .return {"\\n"}
        .if {ch == "\r"} .return {"\\r"}
        .if {ch == "\t"} .return {"\\t"}
        .if {ch == "\""} .return {"\\\""}
        .if {mustEscape.isMatch(ch)}
          .error {Infos.msg ("Unexpected special character sequence: "+(ch.utf8.flow.map{b -> b.str}.join ","))}
        .return {ch}
        }
      .join ""
      },
  }

//---File json/validate.fear
package base.json

ValidateInput: {#(input: Str): mut Action[Str] -> Block#
  .let invalidChars = {Regexs#"[[^\\U{1F}-\\U{10FFFF}]&&[^\\U{20}\\U{A}\\U{D}\\U{9}]]"}
  .return {{res -> invalidChars.isMatch(input) ? {
    .then -> res.info(Infos.msg("JSON may not contain any non-whitespace control characters.")),
    .else -> res.ok(input + "\u0003"), // append END OF TEXT character for the lexer
    }}}
  }

//---File json/parser/parser.fear
package base.json

ParseJson: {#(rawInput: Str): mut Action[Json] -> ValidateInput#(rawInput).andThen{input ->
  {res -> Try#{AtomiseStr#input
    .actor[mut _LexerCtx,Token](_LexerCtxs#, LexJson)
    .actor[mut Var[mut _ParserActor],Json](
      Vars#[mut _ParserActor](mut _TopLevelParser),
      {downstream, ctx, token -> ctx.get#(downstream, ctx, token)}
      )
    .get
    }.run{
      .ok(json) -> res.ok(json),
      .info(info) -> res.info(Infos.msg("Invalid string found, expected JSON.\n"+(info.msg))),
      }
    }
  }}

_ParserActor: {
  mut #(downstream: mut Sink[Json], state: mut Var[mut _ParserActor], e: Token): ActorRes
  }
_TopLevelParser: _ParserActor{downstream, behaviour, token -> Block#
  .do {behaviour.set(_ValueParser#({value -> downstream#value}, this))}
  .return {behaviour.get#(downstream, behaviour, token)}
  }
_ValueParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> {'parser
  downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
    .mode -> "value", .token -> token,
    .true -> Block#(collector#(Jsons.bool True), behaviour.set(old), ActorRes.continue),
    .false -> Block#(collector#(Jsons.bool False), behaviour.set(old), ActorRes.continue),
    .null -> Block#(collector#(Jsons.null), behaviour.set(old), ActorRes.continue),
    .quoted(str) -> Block#(collector#(Jsons.string str), behaviour.set(old), ActorRes.continue),
    .numeric(num) -> Block#(collector#(Jsons.number num), behaviour.set(old), ActorRes.continue),
    .os -> Block#(behaviour.set(_ArrayParser#(collector, old)), ActorRes.continue),
    .oc -> Block#(behaviour.set(_ObjectParser#(collector, old)), ActorRes.continue),
    })
  }}

_ArrayParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> Block#
  .let[mut IsoPod[iso List[Json]]] es = {IsoPod#(List#)}
  .let[mut Consumer[Json]] collector' = {{value -> es.mutate{es' -> es'.add(value)}!}}
  .return {{'parser
    downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
      .mode -> "array", .token -> token,
      .cs -> Block#(collector#(Jsons.array(es!)), behaviour.set(old), ActorRes.continue),
      .default(_) -> _ValueParser
        #(collector', _ArrayCommaParser#(collector', parser))
        #(downstream, behaviour, token),
      })
    }}
  }
_ArrayCommaParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> {'parser
  downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
    .mode -> "comma or end of array", .token -> token,
    .cs -> old#(downstream, behaviour, token),
    .comma -> Block#(
      behaviour.set(_ValueParser#(collector, parser)),
      ActorRes.continue
      ),
    })}
  }

_ObjectParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> Block#
  .let[mut IsoPod[iso LinkedHashMap[Str,Json]]] es = {IsoPod#(Maps.hashMap[Str,Json]({k1,k2 -> k1 == k2}, {k->k}))}
  .let[mut Consumer[Str,Json]] collector' = {{key, value -> es.mutate{es' -> es'.put(key, value)}!}}
  .return {{'parser
    downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
      .mode -> "object", .token -> token,
      .cc -> Block#(collector#(Jsons.object(es!)), behaviour.set(old), ActorRes.continue),
      .quoted(_) -> Block#
        .let keyParser = {_MemberKeyParser#(collector', parser)}
        .do {behaviour.set(keyParser)}
        .return {keyParser#(downstream, behaviour, token)},
      })
    }}
  }
_MemberKeyParser: {#(collector: mut Consumer[Str,Json], old: mut _ParserActor): mut _ParserActor -> Block#
  .let[mut Str] key = {mut ""}
  .let hasKey = {Vars#[Bool]False}
  .return {{downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{'matcher
    .mode -> "object member key", .token -> token,
    .quoted(str) -> key.isEmpty ? {
      .then -> Block#(key.append(str), hasKey.set(True), ActorRes.continue),
      .else -> matcher.default(mut "string \"" + str + "\""),
      },
    .colon -> hasKey.get.not ? {
      .then -> matcher.default("':'"),
      .else -> Block#(behaviour.set(_MemberValueParser#(collector, old, key.str)), ActorRes.continue),
      },
    })}}
  }
_MemberValueParser: {#(collector: mut Consumer[Str,Json], old: mut _ParserActor, key: Str): mut _ParserActor -> {'parser
  downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
    .mode -> "object member value", .token -> token,
    .default(_) -> Block#
      .let[mut Consumer[Json]] collector' = {{value -> collector#(key, value)}}
      .return {_ValueParser
        #(collector', _ObjectCommaParser#(collector, old))
        #(downstream, behaviour, token)},
    })
  }}
_ObjectCommaParser: {#(collector: mut Consumer[Str,Json], old: mut _ParserActor): mut _ParserActor -> {'parser
  downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
    .mode -> "comma or end of object", .token -> token,
    .cc -> old#(downstream, behaviour, token),
    .comma -> Block#(
      behaviour.set(old),
      ActorRes.continue
      ),
    })}
  }

TopLevelMatch: {
  #(downstream: mut Sink[Json],
    ctx: mut Var[mut Opt[mut _SubMatch[ActorRes]]],
    token: Token
  ): mut _SubMatch[ActorRes] -> {
    .mode -> "value", .token -> Tokens.null(0, 0),
    .quoted(str) -> Block#(downstream#(Jsons.string str), ActorRes.continue),
    .os -> Block#(
      ctx.set(Opts#{
        .mode -> "array", .token -> token,
        }),
      ActorRes.continue
      )
    }}

_SubMatch[R:iso,imm,mut,mutH,read,readH]: TokenMatch[R]{
  read .mode: Str,
  read .token: Token,
  read .errorSuffix: Str -> mut " at " + (this.token.line.str) + ":" + (this.token.col.str),
  mut .default(kind: Str): R -> Error.msg (mut "Unexpected " + kind + " when parsing a JSON " + (this.mode) + (this.errorSuffix)),
  .true -> this.default("'true'"),
  .false -> this.default("'false'"),
  .null -> this.default("'null'"),
  .quoted(chars) -> this.default(mut "string \"" + chars + "\""),
  .numeric(num) -> this.default("number " + (num.str)),
  .os -> this.default("'['"),
  .cs -> this.default("']'"),
  .oc -> this.default("'{'"),
  .cc -> this.default("'}'"),
  .comma -> this.default("','"),
  .colon -> this.default("':'"),
  }

//---File json/lexer/digits.fear
package base.json

LexNum: {#(
  downstream: mut Sink[Token],
  ctx: mut _LexerCtx,
  e: Str,
  parent: mut Actor[mut _LexerCtx,Str,Token]
  ): ActorRes -> Block#
    .do {Block#(ctx.col++)}
    .if {ctx.isDigit(e)} .return {Block#(ctx.write(e), ActorRes.continue)}
    .return {ctx.str.float.run{
      .ok(f) -> Block#(
        downstream#(Tokens.numeric(ctx.line.get, ctx.col.get, f)),
        ctx.clear,
        ctx.mode(_LexerModes.value),
        parent#(downstream, ctx, e)
        ),
      .info(i) -> Block#(
        downstream#(Tokens.unknownFragment(ctx.line.get, ctx.col.get, ctx.str)),
        ActorRes.stop
        ),
      }}
  }

//---File json/lexer/string.fear
package base.json

LexString: Actor[mut _LexerCtx,Str,Token]{downstream, ctx, e -> Block#
  .do {Block#(ctx.col++)}
  .if {e == "\""} .return {Block#(
    downstream#(Tokens.quoted(ctx.line.get, ctx.col.get, ctx.str)),
    ctx.clear,
    ctx.mode(_LexerModes.value),
    ActorRes.continue
    )}
  .if {e == "\\"} .return {Block#(
    ctx.mode(_LexerModes.stringEscape),
    ActorRes.continue
    )}
  .do {ctx.write(e)}
  .if {ctx.isChar(e)} .return {ActorRes.continue}
  .do {downstream#(Tokens.unknownFragment(ctx.line.get, ctx.col.get, ctx.str))}
  .return {ActorRes.stop}
  }

LexStringEscapes: Actor[mut _LexerCtx,Str,Token]{downstream, ctx, e -> Block#
  .do {Block#(ctx.col++)}
  .if {e == "\""} .return {Block#(ctx.write(e), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "\\"} .return {Block#(ctx.write(e), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "/"} .return {Block#(ctx.write(e), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "b"} .return {Block#(ctx.write("\b"), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "f"} .return {Block#(ctx.write("\f"), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "n"} .return {Block#(ctx.write("\n"), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "r"} .return {Block#(ctx.write("\r"), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "t"} .return {Block#(ctx.write("\t"), ctx.mode(_LexerModes.string), ActorRes.continue)}
  .if {e == "u"} .return {Block#(ctx.mode(_LexerModes.unicodeEscape), ActorRes.continue)}
  .do {downstream#(Tokens.unknownFragment(ctx.line.get, ctx.col.get, ctx.str))}
  .return {ActorRes.stop}
  }

LexUnicodeEscapes: {
  #(ctx: mut _LexerCtx,
    buffer: mut List[Str],
    e: Str
  ): ActorRes -> Block#
    .do {Block#(ctx.col++)}
    .do {buffer.add(e)}
    .if {buffer.size < 4} .return {ActorRes.continue}
    .let[Nat] codePoint = {_ParseHex#(buffer)}
    .if {UTF16.isSurrogate(codePoint)} .return {Block#
      .if {ctx.unpairedSurrogate.size == 1} .return {Block#
        .do {ctx.write(UTF16.fromSurrogatePair(ctx.unpairedSurrogate.get(0), codePoint))}
        .do {ctx.unpairedSurrogate.clear}
        .do {ctx.mode(_LexerModes.string)}
        .return {ActorRes.continue}
        }
      .assert({ctx.unpairedSurrogate.isEmpty}, "unpairedSurrogate was not empty")
      .do {ctx.unpairedSurrogate.add(codePoint)}
      .do {ctx.mode(_LexerModes.string)}
      .return {ActorRes.continue}
      }
    .do {ctx.write(UTF16.fromCodePoint(codePoint))}
    .do {ctx.mode(_LexerModes.string)}
    .return {ActorRes.continue},
  }

_ParseHex: {
  #(chars: read List[Str]): Nat -> chars.flow
    .map{ch -> this.encoding(ch)}
    #(Flow.enumerate[Nat])
    .fold[Nat]({0}, {acc, ni -> Block#
      .let digit = {ni.e}
      .let place = {chars.size - (ni.i + 1)}
      .return {acc + (digit * (16 ** place))}
      }),

  .encoding(ch: Str): Nat -> Block#
    .if {ch == "0"} .return {0}
    .if {ch == "1"} .return {1}
    .if {ch == "2"} .return {2}
    .if {ch == "3"} .return {3}
    .if {ch == "4"} .return {4}
    .if {ch == "5"} .return {5}
    .if {ch == "6"} .return {6}
    .if {ch == "7"} .return {7}
    .if {ch == "8"} .return {8}
    .if {ch == "8"} .return {8}
    .if {ch == "9"} .return {9}
    .if {ch == "A"} .return {10}
    .if {ch == "a"} .return {10}
    .if {ch == "B"} .return {11}
    .if {ch == "b"} .return {11}
    .if {ch == "C"} .return {12}
    .if {ch == "c"} .return {12}
    .if {ch == "D"} .return {13}
    .if {ch == "d"} .return {13}
    .if {ch == "E"} .return {14}
    .if {ch == "e"} .return {14}
    .if {ch == "F"} .return {15}
    .if {ch == "f"} .return {15}
    .return {Error.msg("Invalid hex digit: " + ch)},
  }

//---File json/lexer/lexer.fear
package base.json

LexJson: Actor[mut _LexerCtx,Str,Token]{downstream, ctx, e -> e == "\u0003" ? {
  .then -> Block#
    .if {ctx.str.isEmpty.not} .do {downstream#(Tokens.unknownFragment(ctx.line.get, ctx.col.get, ctx.str))}
    .return {ActorRes.continue},
  .else -> ctx.mode.match{
    .value -> Block#
     .do {e == "\n" ? {
       .then -> Block#(ctx.line++, ctx.col := 1),
       .else -> Block#(ctx.col++)
       }}
     .if {ctx.isWhitespace(e)} .return {ActorRes.continue}
     .if {ctx.isEmpty} .return {_LexStartingToken#(downstream, ctx, e)}
     .do {ctx.write(e)}
     .if {ctx.str == "true"} .return {Block#(downstream#(Tokens.true(ctx.line.get, ctx.col.get)), ctx.clear, ActorRes.continue)}
     .if {ctx.str == "false"} .return {Block#(downstream#(Tokens.false(ctx.line.get, ctx.col.get)), ctx.clear, ActorRes.continue)}
     .if {ctx.str == "null"} .return {Block#(downstream#(Tokens.null(ctx.line.get, ctx.col.get)), ctx.clear, ActorRes.continue)}
     .if {ctx.str.size > 5} .return {Block#(
       downstream#(Tokens.unknownFragment(ctx.line.get, ctx.col.get, ctx.str)),
       ActorRes.stop
       )}
     .return {ActorRes.continue},
    .string -> LexString#(downstream, ctx, e),
    .stringEscape -> LexStringEscapes#(downstream, ctx, e),
    .unicodeEscape(buf) -> LexUnicodeEscapes#(ctx, buf, e),
    .digits -> LexNum#(downstream, ctx, e, mut LexJson),
    }
  }}

_LexerCtxs: {#: mut _LexerCtx -> Block#
  .let buffer = {mut ""}
  .let mode = {Vars#[mut _LexerMode](_LexerModes.value)}
  .let isDigit = {Regexs#"[0-9eE\\-+\\.]"}
  .let isNumberStart = {Regexs#"[\\-0-9]"}
  .let isWhitespace = {Regexs#"[ \\n\\r\\t]"}
  .let isChar = {Regexs#"[\\U{0020}-\\U{10FFFF}]"}
  .let unpairedSurrogate = {List.withCapacity[Nat](1)}
  .let line = {Count.nat(1)}
  .let col = {Count.nat(1)}
  .return {mut _LexerCtx: Stringable{'ctx
    read .isEmpty: Bool -> buffer.isEmpty,
    mut .write(e: Str): Void -> buffer.append(e),
    mut .clear: Void -> buffer.clear,
    .str -> buffer.str,
    mut .mode: mut _LexerMode -> mode.get,
    mut .mode(next: mut _LexerMode): Void -> mode.set(next),
    read .isDigit(ch: Str): Bool -> isDigit.isMatch(ch),
    read .isNumberStart(ch: Str): Bool -> isNumberStart.isMatch(ch),
    read .isWhitespace(ch: Str): Bool -> isWhitespace.isMatch(ch),
    read .isChar(ch: Str): Bool -> isChar.isMatch(ch),
    mut .unpairedSurrogate: mut List[Nat] -> unpairedSurrogate,
    mut .line: mut Count[Nat] -> line,
    mut .col: mut Count[Nat] -> col,
    }}
  }

_LexStartingToken: Actor[mut _LexerCtx,Str,Token]{downstream, ctx, e -> Block#
  .if {ctx.isNumberStart(e)}
    .return {Block#(
      ctx.write(e),
      ctx.mode(_LexerModes.digits),
      ActorRes.continue
      )}
  .if {e == "\""} .return {Block#(
    ctx.mode(_LexerModes.string),
    ActorRes.continue
    )}
  .if {e == "["} .return {Block#(downstream#(Tokens.os(ctx.line.get, ctx.col.get)), ActorRes.continue)}
  .if {e == "]"} .return {Block#(downstream#(Tokens.cs(ctx.line.get, ctx.col.get)), ActorRes.continue)}
  .if {e == "{"} .return {Block#(downstream#(Tokens.oc(ctx.line.get, ctx.col.get)), ActorRes.continue)}
  .if {e == "}"} .return {Block#(downstream#(Tokens.cc(ctx.line.get, ctx.col.get)), ActorRes.continue)}
  .if {e == ","} .return {Block#(downstream#(Tokens.comma(ctx.line.get, ctx.col.get)), ActorRes.continue)}
  .if {e == ":"} .return {Block#(downstream#(Tokens.colon(ctx.line.get, ctx.col.get)), ActorRes.continue)}
  .do {ctx.write(e)}
  .return {ActorRes.continue}
  }

TokenMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .true: R,
  mut .false: R,
  mut .null: R,
  mut .quoted(chars: Str): R,
  mut .numeric(num: Float): R,

  mut .os: R,
  mut .cs: R,
  mut .oc: R,
  mut .cc: R,
  mut .comma: R,
  mut .colon: R,

  }
Tokens: {
  .true(line: Nat, col: Nat): Token -> {
    .match(m) -> m.true,
    .line -> line,
    .col -> col,
    },
  .false(line: Nat, col: Nat): Token -> {
    .match(m) -> m.false,
    .line -> line,
    .col -> col,
    },
  .null(line: Nat, col: Nat): Token -> {
    .match(m) -> m.null,
    .line -> line,
    .col -> col,
    },
  .os(line: Nat, col: Nat): Token -> {
    .match(m) -> m.os,
    .line -> line,
    .col -> col,
    },
  .cs(line: Nat, col: Nat): Token -> {
    .match(m) -> m.cs,
    .line -> line,
    .col -> col,
    },
  .oc(line: Nat, col: Nat): Token -> {
    .match(m) -> m.oc,
    .line -> line,
    .col -> col,
    },
  .cc(line: Nat, col: Nat): Token -> {
    .match(m) -> m.cc,
    .line -> line,
    .col -> col,
    },
  .comma(line: Nat, col: Nat): Token -> {
    .match(m) -> m.comma,
    .line -> line,
    .col -> col,
    },
  .colon(line: Nat, col: Nat): Token -> {
    .match(m) -> m.colon,
    .line -> line,
    .col -> col,
    },
  .quoted(line:Nat, col:Nat, chars: Str): Token -> {
    .match(m) -> m.quoted(chars),
    .line -> line,
    .col -> col,
    },
  .numeric(line: Nat, col: Nat, num: Float): Token -> {
    .match(m) -> m.numeric(num),
    .line -> line,
    .col -> col,
    },
  .unknownFragment(line: Nat, col: Nat, bufferContents: Str): Token -> Error.msg (mut "Unknown fragment in JSON code:\n" + bufferContents + " at " + (line.str) + ":" + (col.str)),
  }
Token: {
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut TokenMatch[R]): R,
  read .line: Nat,
  read .col: Nat,
  }

_LexerModeMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .value: R,
  mut .string: R,
  mut .stringEscape: R,
  mut .unicodeEscape(buffer: mut List[Str]): R,
  mut .digits: R,
  }
_LexerModes: {
  .value: mut _LexerMode -> {m -> m.value},
  .string: mut _LexerMode -> {m -> m.string},
  .stringEscape: mut _LexerMode -> {m -> m.stringEscape},
  .unicodeEscape: mut _LexerMode -> Block#
    .let[mut List[Str]] buffer = {List.withCapacity(4)}
    .return {{m -> m.unicodeEscape(buffer)}},
  .digits: mut _LexerMode -> {m -> m.digits},
  }
_LexerMode: {mut .match[R:iso,imm,mut,mutH,read,readH](m: mut _LexerModeMatch[R]): R}

//---File flows.fear
package base

alias base.flows.Flow as Flow,
alias base.flows.FlowOp as FlowOp,
alias base.flows.ControlFlow as FlowCtrl,
alias base.flows._Sink as FlowSink,
alias base.flows.RestrictFlowReuse as RestrictFlowReuse,
alias base.flows.ActorRes as ActorRes,

//---File repr.fear
package base.repr

alias base.Str as Str,
alias base.F as F,//check if we can 'import F[T]'
alias base.Block as Block,
alias base.Void as Void,
alias base.Error as Error,
alias base.Bool as Bool,

FRepr[T:imm]:F[iso T, F[read T,Bool], mut Repr[T]]{
  _x,_inv->Block#
   .openIso x = _x
   .let[mut Repr[T]] res= {mut Repr[T:imm]:{'repr
    read .look[R](f:read F[read T,imm R]): imm R ->f#x,
    mut  .mutate[R](f:read F[mut T,imm R]): imm R -> Block#
      .let[imm R] res={f#x}
      .do{repr.reset}
      .return {res},
    mut  .reset:Void->_inv#x?{.then->Void,.else->Error.msg "AAAH",},
    read .cached[R](f:F[read T,imm R]): imm R ->f#x, //magic
     }}
   .do {res.reset}
   .return {res}
  }








//---File test/printReports.fear
package base.test

ResultPrinters: F[mut IO, mut ResultPrinter]{io -> mut ResultPrinter: ResultReporter{#(results) -> Block#
  .let[Str] resultsMsg = {results.flow.map{suite -> _TextUtils.suite(suite, +1)}.join "\n\n"}
  .do {io.printlnErr("# Test Results\n" + resultsMsg)}
  .return {Void}
  }}

_TextUtils: {
  .results(results: read List[TestResult]): mut Flow[Str] -> results.flow
    .map{result -> result.title+" - "+(this.status(result.kind))},

  .suite(suite: read TestResults, depth: Int): Str ->
    this.heading(suite.suiteTitle, depth)
    + "\n"
    + (this.results(suite.results).join "\n\n")
    + (suite.nestedResults.isEmpty ?[Str] {.then -> "", .else -> "\n\n"})
    + (suite.nestedResults.flow.map{nested -> this.suite(nested, depth + +1)}.join "\n"),

  .heading(title: Str, depth: Int): Str -> Block#
    .if {depth > +5} .return {"**"+title+"**  "}
    .return {Flow.range(+0, depth + +1).map[Str]{_ -> "#"}.join("") + " " + title},

  .status(kind: TestResultKind): Str -> kind.match{
    .passed -> "PASSED",
    .skipped -> "SKIPPED",
    .failed(details) -> "FAILED\n```\n"+(details)+"\n```",
    .errored(details) -> "ERRORED\n```\n"+(details)+"\n```",
    },
  }

//---File test/pkg.fear
package base.test

alias base.Block as Block,
alias base.Sealed as Sealed,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Nat as Nat, alias base.Int as Int, alias base.Float as Float,
alias base.Str as Str,
alias base.F as F, alias base.Consumer as Consumer,
alias base.Main as AppMain, alias base.caps.System as System,
alias base.List as List,
alias base.caps.UnrestrictedIO as UnrestrictedIO, alias base.caps.IO as IO,
alias base.Opt as Opt,
alias base.Info as Info,
alias base.flows.Flow as Flow,
alias base.caps.CapTrys as CapTrys, alias base.caps.CapTry as CapTry,

//---File test/testRunner.fear
package base.test

Main: AppMain{
  #(sys) -> Block#
    .do {Block#(this.testMain(sys.iso.self, FTestRunner#(sys.iso.self)))}
    .return {Void},
  .testMain(system: iso System, runner: iso TestRunner): List[read TestResults]
  }

FTestRunner: F[mut System, mut TestRunner]{sys -> Block#
  .let[mut List[Test]] tests = {List#}
  .let[mut List[mut TestSuite]] suites = {List#}
  .let[mut List[mut ResultReporter]] reporters = {List#}
  .let[mut CapTry] try = {sys.try}
  .return {{'self
    .suite(title, registerTests) -> Block#
      .do {suites.add({.title -> title, .runner -> registerTests#(FTestRunner#sys)})}
      .return {self},

    .test(title, impl) -> Block#
      .do {tests.add({.title -> title, .impl -> impl})}
      .return {self},

    .withReporter(reporter) -> Block#
      .do {reporters.add(reporter)}
      .return {self},

    .run -> Block#
      .let[mut List[read TestResults]] results = {List#[read TestResults](FTestResults#("<unnamed>", self.runDirectTests[], self.runSuiteTests[]))}
      .do {reporters.iter.for{reporter -> reporter#results}}
      .return {results},
    mut .runDirectTests: mut List[TestResult] -> tests.iter
      .map{test -> Block#
        .return {FTestResult#(test.title, try#(sys.iso.self, {sys' -> test.impl#sys'}).run{
          .ok(_) -> FTestResultKind.passed,
          .info(info) -> FTestResultKind.errored(info.str)
          })}
        }
      .list,
    mut .runSuiteTests: mut List[read TestResults] -> suites.flow
      .map[read TestResults]{suite -> Block#
        .let[read List[read TestResults]] suiteResults = {suite.runner.run}
        .return {FTestResults#(
          suite.title,
          suiteResults.flow
           .flatMap{subSuite->subSuite.results.flow}
           .list,
          suiteResults.flow
            .flatMap{subSuite->subSuite.nestedResults.flow}
            .list
          )}
        }
      .list,
    }}
  }
TestRunner: {
  mut .suite(title: Str, registerTests: F[mut TestRunner, mut TestRunner]): mut TestRunner,
  mut .test(title: Str, impl: AppMain): mut TestRunner,
  mut .withReporter(reporter: mut ResultReporter): mut TestRunner,
  mut .run: read List[read TestResults],
  }

TestSuite: {read .title: Str, mut .runner: mut TestRunner}
Test: {read .title: Str, read .impl: AppMain}
FTestResults: F[Str, read List[TestResult], read List[read TestResults], read TestResults]{suiteTitle, results, nested -> mut TestResults: {
  read .suiteTitle: Str -> suiteTitle,
  read .results: read List[TestResult] -> results,
  read .nestedResults: read List[read TestResults] -> nested,
  }}
FTestResult: F[Str, TestResultKind, TestResult]{
  #(title, kind) -> {
    .title -> title,
    .kind -> kind,
    },
  .withInfo(title: Str, kind: TestResultKind, info: Opt[Info]): TestResult -> {
    .title -> title,
    .kind -> kind,
    .info -> info,
    },
  }
TestResult: {
  read .title: Str,
  read .kind: TestResultKind,
  read .info: Opt[Info] -> {},
  }

TestResultKind: Sealed{.match[R](m: mut TestResultKindMatcher[R]): R}
FTestResultKind: {
  .passed: TestResultKind -> {.match(m) -> m.passed},
  .skipped: TestResultKind -> {.match(m) -> m.skipped},
  .failed(details: Str): TestResultKind -> {.match(m) -> m.failed(details)},
  .errored(details: Str): TestResultKind -> {.match(m) -> m.errored(details)},
  }
TestResultKindMatcher[R]: {
  mut .passed: R,
  mut .skipped: R,
  mut .failed(details: Str): R,
  mut .errored(details: Str): R,
  }

ResultReporter: {
  mut #(results: read List[read TestResults]): Void,
  }

//---File test/junitReports.fear
package base.test


//---File assertions.fear
package base

Assert:Sealed{
  !(assertion: Bool): Void -> this!(assertion, { Void }),
  ![R](assertion: Bool, cont: mut AssertCont[R]): R -> assertion ? {
    .then -> cont#,
    .else -> this._fail
    },
  ![R](assertion: Bool, msg: Str, cont: mut AssertCont[R]): R -> assertion ? {
      .then -> cont#,
      .else -> this._fail(msg)
      },
  ._fail[R]: R -> Magic!,
  ._fail[R](msg: Str): R -> Magic!,
  }
AssertCont[R]:{ mut #: R }

//---File bools.fear
package base
Bool: Sealed,Stringable,ToImm[Bool]{
  .and(b: Bool): Bool,
  &&(b: mut MF[Bool]): Bool -> this.and(b#),
  &(b: Bool): Bool -> this.and(b),
  .or(b: Bool): Bool,
  |(b: Bool): Bool -> this.or(b),
  ||(b: mut MF[Bool]): Bool -> this.or(b#),
  .not: Bool,
  .if[R:read,mut,imm,iso](f: mut ThenElse[R]): R,
  ?[R:read,mut,imm,iso](f: mut ThenElse[R]): R -> this.if(f),
  }
True: Bool{ .and(b) -> b, .or(b) -> this, .not -> False, .if(f) -> f.then(), .str -> "True", .toImm -> True }
False: Bool{ .and(b) -> this, .or(b) -> b, .not -> True, .if(f) -> f.else(), .str -> "False", .toImm -> False }
ThenElse[R:read,mut,imm,iso]: { mut .then: R, mut .else: R, }

//---File regex.fear
package base

Regexs: Sealed{#(pattern: Str): Regex -> Regex: Stringable{
  .str -> Magic!,
  .isMatch(haystack: Str): Bool -> Magic!,
  }}

//---File bytes.fear
package base

Bytess: {
  .fromList(list: read List[Byte]): Bytes -> Magic!,
  }

Bytes: {
  mut .read(i: Nat): Byte -> Error.msg ("The index "+(i.str)+" is out of bounds."),
  mut .list: List[Byte] -> List#,

  read .size: Nat -> 0,
  read .isEmpty: Bool -> True,
  }

//---File either.fear
package base

Either[A,B]:{
  mut  .match[R:iso,imm,mut,mutH,read,readH](m: mut EitherMatch[A, B, R]): R,
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut EitherMatch[read A, read B, R]): R,
  imm  .match[R:iso,imm,mut,mutH,read,readH](m: mut EitherMatch[imm A, imm B, R]): R,
  }
EitherMatch[A,B,R:iso,imm,mut,mutH,read,readH]:{
  mut .a(x: A): R,
  mut .b(x: B): R,
  }

//---File benchmarking.fear
package base.benchmarking
alias base.Magic as Magic,
alias base.Nat as Nat,
alias base.Void as Void,

BlackBox: {
  #[T:imm,mut,read](value: T): Void -> Magic!,
  .consumeCpu(tokens: Nat): Void -> Magic!,
  }

//---File flows/internals.fear
package base.flows

_FlowFactory: {
  .fromOp[E](source: mut FlowOp[E], size: Opt[Nat]): mut Flow[E],
  }

_EmptyCtx: ToIso[_EmptyCtx]{
  .iso -> iso _EmptyCtx,
  .self -> this,
  }

//---File flows/dataParallel.fear
package base.flows

_DataParallelFlow: _FlowFactory{
  .fromOp[E](source: mut FlowOp[E], size: Opt[Nat]): mut Flow[E] -> Magic!,
  }

_DataParallelInvalidStateful: {![R]: R ->
  Error.msg "Stateful operators are invalid in data-parallel flows. If you see this, there is a bug in the Fearless compiler."
  }

//---File flows/pkg.fear
package base.flows

alias base.Block as Block, alias base.Continuation as Continuation,
alias base.Sealed as Sealed,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Nat as Nat, alias base.Int as Int, alias base.Float as Float,
alias base.Str as Str,
alias base.F as F, alias base.Consumer as Consumer, alias base.MF as MF,
alias base.Extensible as Extensible, alias base.Extension as Extension,
alias base.Var as Var, alias base.Count as Count,
alias base.Opts as Opts, alias base.Opt as Opt,
alias base.Let as Let,
alias base.List as List,
alias base.Error as Error, alias base.Infos as Infos, alias base.Info as Info,
alias base.Ordering as Ordering,
alias base.Magic as Magic,
alias base.IsoPod as IsoPod,
alias base.ControlFlow as ControlFlow,
alias base.Action as Action,
alias base.ToIso as ToIso,
alias base.Unreachable as Unreachable,

//---File flows/flows.fear
package base.flows
alias base.Todo as Todo,

Flow: Sealed, _FlowExtensions, _FlowConverters{
  #[E]: mut Flow[E] -> mut EmptyFlow[E],
  #[E](e: E): mut Flow[E] -> _SeqFlow#[E](e),
  #[E](e1: E, e2: E): mut Flow[E] -> List#(e1, e2).flow,
  #[E](e1: E, e2: E, e3: E): mut Flow[E] -> List#(e1, e2, e3).flow,
  #[E](e1: E, e2: E, e3: E, e4: E): mut Flow[E] -> List#(e1, e2, e3, e4).flow,

  .fromOp[E](source: mut FlowOp[E]): mut Flow[E] -> _SeqFlow.fromOp(source, {}),
  .fromOp[E](source: mut FlowOp[E], size: Nat): mut Flow[E] -> _SeqFlow.fromOp(source, Opts#size),

  .fromMutSource[E](source: mut FlowOp[E]): mut Flow[E] -> _MutSourceCollection[E]#source,
  .fromMutSource[E](source: mut FlowOp[E], size: Nat): mut Flow[E] -> _MutSourceCollection[E]#(source, size),
  }

Flow[E]: Sealed, Extensible[Flow[E]], _NonTerminalOps[E], _TerminalOps[E]{
  .self -> this,
  mut .let[DR,R](x: read F[mut MF[mut Flow[E]],DR], cont: mut Continuation[DR,mut Flow[E],R]): R -> Block#
    .let duplicator = {_LazyFlowDuplicators#this}
    .let splitResult = {x#duplicator}
    .let[mut Flow[E]] selfFlow = {duplicator.collected.match{
      .some(collected) -> collected.flow,
      .empty -> this,
      }}
    .return {cont#(splitResult, selfFlow)},
  mut .join(j: Joinable[E]): E -> j.join(this),
  mut .unwrapOp(unwrap: mut _UnwrapFlowToken): mut FlowOp[E],
  mut .only: mut Action[E] -> {res -> Block#
    .let found = {this.limit(2).list}
    .if {found.size == 1} .return {res.ok(found.get(0))}
    .return {res.info(Infos.msg("Expected exactly one element, found at least " + (found.size.str)))}
    },
  mut .get: E -> this.only!,
  mut .opt: mut Opt[E] -> Block#
    .let found = {this.limit(2).list}
    .if {found.size > 1}
      .error {Infos.msg("Expected exactly one element, found at least " + (found.size.str))}
    .return {found.tryGet(0)},
  }
_UnwrapFlowToken: {}

_NonTerminalOps[E]: {
  mut .filter(predicate: read F[E, Bool]): mut Flow[E],

  mut .map[R](f: read F[E, R]): mut Flow[R],
  mut .map[C,R](ctx: iso ToIso[C], f: read F[iso C, E, R]): mut Flow[R],

  mut .peek(f: read F[E, Void]): mut Flow[E] -> this.map{e -> Block#(f#e, e)},
  mut .peek[C](ctx: iso ToIso[C], f: read F[iso C, E, Void]): mut Flow[E] ->
    this.map(ctx, {c, e -> Block#(f#(c, e), e)}),

  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R],
  mut .with[EB](other: mut Flow[EB]): mut Flow[mut Pair[E,EB]],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R],
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R],

  mut .limit(n: Nat): mut Flow[E],

  mut .scan[S:imm](acc: imm S, f: read F[S,E,S]): mut Flow[imm S] -> this.actor[mut Var[imm S], imm S](Vars#[imm S]acc, {downstream, acc', e -> Block#(
    acc' := (f#(acc'.get, e)),
    downstream#(acc'.get),
    ActorRes.continue
    )}),
  }
_TerminalOps[E]: Sealed{

  mut .first: mut Opt[E],
  mut .last: mut Opt[E] -> this.fold[mut Opt[E]]({{}}, {_, e -> Opts#e}),
  mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R],
  mut .fold[S](acc: iso MF[S], f: read F[S,E,S]): S,
  mut .size: Nat,

  mut .find(predicate: read F[E, Bool]): mut Opt[E] -> this.findMap{e -> predicate#e ? {.then -> Opts#e, .else -> {}}},
  mut .first(predicate: read F[E, Bool]): mut Opt[E] -> this.find(predicate),
  mut .any(predicate: read F[E, Bool]): Bool -> this
    .findMap{e -> predicate#e ? {.then -> Opts#True, .else -> {}}}
    .isSome,
  mut .all(predicate: read F[E, Bool]): Bool -> this
    .findMap{e -> predicate#e ? {.then -> {}, .else -> Opts#False}}
    .isEmpty,
  mut .none(predicate: read F[E, Bool]): Bool -> this.all{e -> predicate#e.not},
  mut .for(f: read F[E, Void]): Void -> this.fold({Void}, {_, e -> f#e}),
  mut .forEffect(f: mut MF[E, Void]): Void -> this.list.iter.for{e -> f#e},
  mut .list: mut List[E] -> this.fold({List#[E]}, {acc, e -> acc + e}),
  mut .max(compare: read F[E, E, Ordering]): mut Opt[E] -> this.fold[mut Opt[E]]({{}}, {max, b -> max.match{
    .empty -> Opts#b,
    .some(a) -> compare#(a, b).match{
      .less -> Opts#b,
      .equal -> max,
      .greater -> max,
      }
    }})
  }

_FlowExtensions: {
  .sum: mut Extension[mut Flow[Int], Int] -> {flow -> flow.fold[Int]({+0}, {acc, e -> acc + e})},
  .uSum: mut Extension[mut Flow[Nat], Nat] -> {flow -> flow.fold[Nat]({0}, {acc, e -> acc + e})},
  .fSum: mut Extension[mut Flow[Float], Float] -> {flow -> flow.fold[Float]({0.0}, {acc, e -> acc + e})},

  .enumerate[E:imm]: mut Extension[mut Flow[E], mut Flow[Enumerated[E]]] -> {flow ->
    flow.actor[mut Count[Nat],Enumerated[E]](Count.nat(0), {downstream, i, e ->
      Block#(downstream#(_Enumerateds#(i++, e)), {})
      })
    },
  }

EmptyFlow[E]: Flow[E]{
  .filter(p) -> this,
  mut .with[EB](other: mut Flow[EB]): mut Flow[mut Pair[E,EB]] -> mut EmptyFlow[mut Pair[E,EB]],

  mut .map[R](f: read F[E, R]): mut Flow[R] -> mut EmptyFlow[R],
  .map(_,_) -> this.map({_ -> Unreachable!}),

  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R] -> mut EmptyFlow[R],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] -> mut EmptyFlow[imm R],
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] -> mut EmptyFlow[R],
  .limit(_) -> this,
  .first -> {},
  .findMap(_) -> {},
  .find(_) -> {},
  .any(p) -> False,
  .all(p) -> False,
  .fold(acc, _) -> acc#,
  .size -> 0,
  .unwrapOp(_) -> {
    .step(_) -> {},
    .stop -> {},
    .isRunning -> False,
    },
  }

TerminalOnInfiniteError: { #: Info -> Infos.msg "Terminal operators cannot be called on infinite flows. Use an operation like .limit(5) to bound the flow." }

_LimitSize: {#(n: Nat, size: Opt[Nat]): Opt[Nat] ->
  size.map{beforeLimit ->
    beforeLimit > n ? { .then -> n, .else -> beforeLimit, }
    }
  }

_Enumerateds: {#[E:imm](i: Nat, e: E): Enumerated[E] -> Enumerated[E:imm]: {
  .i: Nat -> i,
  .e: E -> e,
  }}

Pair[A,B]: {mut .a: A, mut .b: B}

//---File flows/operators.fear
package base.flows


FlowOp[E]: {
  mut .step(sink: mut _Sink[E]): Void,
  mut .stop: Void,
  mut .isRunning: Bool,
  mut .for(downstream: mut _Sink[E]): Void -> Block#
    .loop {Block#
      .if {this.isRunning.not} .return {ControlFlow.break}
      .do {this.step(downstream)}
      .return {ControlFlow.continue}
      }
    .return {Void},
  mut .isFinite: Bool -> True,
  mut .split: mut Opt[mut FlowOp[E]] -> {},
  read .canSplit: Bool -> False,
  }


_Sink: {
  #[T](s: mut _Sink[T]): mut _Sink[T] -> s,
  }
_Sink[T]: {
  mut #(x: T): Void,
  mut .pushError(info: Info): Void,
  mut .stop: Void,
  }


_Filter: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], predicate: read F[E, Bool]): mut FlowOp[E] -> Block#
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> predicate#e ? {.then -> downstream#e, .else -> {}},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> predicate#e ? {.then -> downstream#e, .else -> {}},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
      .split -> upstream.split.map{right -> this#(sinkFactory, right, predicate)},
      }}
  }
_Map: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, R]): mut FlowOp[R] ->
    this#[_EmptyCtx,E,R](sinkFactory, upstream, iso _EmptyCtx, {_,e -> f#e}),
  #[C,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], ctx: iso ToIso[C], f: read F[iso C, E, R]): mut FlowOp[R] -> Block#
    .openIso ctx' = ctx
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return  {{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> downstream#(f#(ctx'.iso.self, e)),
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> downstream#(f#(ctx'.iso.self, e)),
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
      .split -> upstream.split.map{right -> this#[C,E,R](sinkFactory, right, ctx'.iso, f)},
    }}
  }
_FlatMap: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, mut Flow[R]]): mut FlowOp[R] -> Block#
    .let[mut Var[Bool]] isRunning = {Vars#[Bool]True}
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .let nestedOp = {f#e.unwrapOp(mut _UnwrapFlowToken)}
              .return {nestedOp.for{
                #(e') -> op.isRunning ? {.then -> downstream#e', .else -> nestedOp.stop},
                .stop -> {},
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .let nestedOp = {f#e.unwrapOp(mut _UnwrapFlowToken)}
              .return {nestedOp.for{
                #(e') -> op.isRunning ? {.then -> downstream#e', .else -> nestedOp.stop},
                .stop -> {},
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> isRunning*,
      .split -> upstream.split.map{right -> this#(sinkFactory, right, f)},
      }}
  }

_With: {
  #[A,B](sinkFactory: _Sink, upstream: mut FlowOp[A], other: mut FlowOp[B]): mut FlowOp[mut Pair[A,B]] -> Block#
    .let[mut Var[Bool]] isRunning = {Vars#[Bool]True}
    .let[mut Var[mut Opt[mut _Sink[A]]]] sink = {Vars#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[A]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .return {other.step{
                #(e') -> op.isRunning ? {.then -> downstream#{.a -> e, .b -> e'}, .else -> other.stop},
                .stop -> op.stop,
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[A]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .return {other.step{
                #(e') -> op.isRunning ? {.then -> downstream#{.a -> e, .b -> e'}, .else -> other.stop},
                .stop -> op.stop,
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> isRunning*,
      .split -> Block#
        .if {upstream.canSplit.not} .return {{}}
        .if {other.canSplit.not} .return {{}}
        .return {Opts#(this#(sinkFactory, upstream.split!, other.split!))},
      }}
  }

//---File flows/statefulOperators.fear
package base.flows

_Limit: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], n: Nat): mut FlowOp[E] -> Block#
    .let[mut Count[Nat]] remaining = {Count.nat(n)}
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return {{ 'runner
      .stop -> Block#(remaining := 0, upstream.stop),
      .isRunning -> remaining* > 0 & (upstream.isRunning),
      .isFinite -> True,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .if {n == 0} .return {runner.stop}
          .do {sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> Block#
              .if {remaining* == 0} .return {runner.stop}
              .do {downstream#e}
              .if {remaining-- <= 1} .return {runner.stop}
              .return {{}},
            .pushError(info) -> remaining* == 0 ? {
              .then -> {},
              .else -> downstream.pushError(info),
              },
            }))}
          .return {upstream.step(sink.get!)}
        },
      }},
  }

_Actor: {
  #[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: iso S, f: read ActorImpl[S,E,R]): mut FlowOp[imm R] ->
    _InternalActor#[S,E,R](sinkFactory, upstream, state, f),

  .anyRet[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: iso S, f: read ActorImplMut[S,E,R]): mut FlowOp[R] ->
    _InternalActor.anyRet[S,E,R](sinkFactory, upstream, state, f),
  }
_InternalActor: {
  #[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: S, f: read ActorImpl[S,E,R]): mut FlowOp[imm R] -> Block#
    .let[mut Var[Bool]] isRunning = {Vars#[Bool]True}
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return {{'op
      .stop -> op.isRunning ? {
       .then -> Block#(isRunning := False, upstream.stop),
       .else -> {}
       },
      .isRunning -> isRunning*,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .let[mut _ActorSink[imm R]] actorSink = {_ActorSinks#downstream}
          .do {sink := (Opts#(sinkFactory#[E]{
            .stop -> Block#(downstream.stop, op.stop),
            #(e) -> isRunning.get ? {
              .then -> f#(actorSink, state, e).match{
                .continue -> {},
                .stop -> Block#(downstream.stop, isRunning := False),
                },
              .else -> op.stop,
              },
            .pushError(info) -> isRunning.get ? {
              .then -> downstream.pushError(info),
              .else -> {},
              },
            }))}
          .return {upstream.step(sink.get!)}
        },
      }},

  .anyRet[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: mut S, f: read ActorImplMut[S,E,R]): mut FlowOp[R] -> Block#
    .let[mut Var[Bool]] isRunning = {Vars#[Bool]True}
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return {{'op
      .stop -> op.isRunning ? {
       .then -> Block#(isRunning := False, upstream.stop),
       .else -> {}
       },
      .isRunning -> isRunning*,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .do {sink := (Opts#(sinkFactory#[E]{
            .stop -> Block#(downstream.stop, op.stop),
            #(e) -> f#(_ActorSinks#downstream, state, e).match{
              .continue -> {},
              .stop -> Block#(downstream.stop, isRunning := False),
              },
            .pushError(info) -> isRunning.get ? {
              .then -> downstream.pushError(info),
              .else -> {},
              },
            }))}
          .return {upstream.step(sink.get!)}
        },
      }},
  }

ActorImpl[S,E,R]: { read #(downstream: mut _ActorSink[imm R], state: S, e: E): ActorRes }
ActorImplMut[S,E,R]: { read #(downstream: mutH _ActorSink[R], state: mutH S, e: E): ActorRes }

ActorRes: Sealed{
  .match[R](m: mut ActorResMatch[R]): R -> m.continue,
  .continue: ActorRes -> {.match(m) -> m.continue},
  .stop: ActorRes -> {.match(m) -> m.stop},
  }
ActorResMatch[R]: { mut .continue: R, mut .stop: R, }

_ActorSinks: {#[T](sink: mut _Sink[T]): mut _ActorSink[T] -> mut _ActorSink[T]: {
  mut #(x: T): Void -> sink#x,
  mut .pushError(info: Info): Void -> sink.pushError(info),
  }}

//---File flows/pipelineParallel.fear
package base.flows

_PipelineParallelSink: _Sink{
  #[T](s: mut _Sink[T]): mut _Sink[T] -> Magic!,
  }
_PipelineParallelSink[T]: _Sink[T]

_PipelineParallelFlow: _FlowFactory{
  .fromOp[E](source: mut FlowOp[E], size: Opt[Nat]): mut Flow[E] -> _RestrictFlowReuse#{'self
    .unwrapOp(_) -> source,
    .filter(p) -> this.fromOp(_Filter#(_PipelineParallelSink, source, p), {}),

    .map(f) -> this.fromOp(_Map#(_PipelineParallelSink, source, f), size),
    .map(ctx, f) -> this.fromOp(_Map#(_PipelineParallelSink, source, ctx, f), size),

    .flatMap(f) -> this.fromOp(_FlatMap#(_PipelineParallelSink, source, f), {}),
    mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] ->
      this.fromOp(_Actor#[S,E,R](_PipelineParallelSink, source, state, f), {}),
    mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] ->
      this.fromOp(_Actor.anyRet[S,E,R](_PipelineParallelSink, source, state, f), {}),
    .limit(n) -> this.fromOp(_Limit#(_PipelineParallelSink, source, n), _LimitSize#(n, size)),
    .with(other) -> this.fromOp(_With#(_PipelineParallelSink, source, other.unwrapOp(mut _UnwrapFlowToken)), {}),

    mut .first: mut Opt[E] -> Block#
      .let[mut Var[mut Opt[E]]] res = {Vars#mut Opt[E]}
      .let stopped = {Vars#[Bool]False}
      .do {source.for(_PipelineParallelSink#[E]{'runner
        .stop -> Block#
          .do {stopped := True}
          .return {source.stop},
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        #(e) -> res.get.isEmpty ? {
          .then -> Block#
            .do {res := (Opts#e)}
            .return {runner.stop},
          .else -> {},
          },
        })}
      .do {source.stop}
      .return {res.get},

    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> Block#
      .let[mut Var[mut Opt[R]]] res = {Vars#mut Opt[R]}
      .let stopped = {Vars#[Bool]False}
      .do {source.for(_PipelineParallelSink#[E]{'runner
        .stop -> Block#
          .do {stopped := True}
          .return {source.stop},
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        #(e) -> res.get.isEmpty ? {
          .then -> f#e.match{
            .some(e') -> Block#
              .do{res := (Opts#e')}
              .return {runner.stop},
            .empty -> {},
            },
          .else -> {},
          },
        })}
      .do {source.stop}
      .return {res.get},

    mut .fold[S](acc: iso MF[S], f: read F[S,E,S]): S -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .openIso initialValueSupplier = acc
      .let[mut Var[S]] acc' = {Vars#(initialValueSupplier#)}
      .let stopped = {Vars#[Bool]False}
      .do {source.for(_PipelineParallelSink#[E]{
        #(e) -> acc' := (f#(acc'.get, e)),
        .stop -> stopped := True,
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        })}
      .do {source.stop}
      .return {acc'.get},

    .size -> size.match{
      .some(n) -> n,
      .empty -> self.fold[Nat]({0}, {acc, _ -> acc + 1}),
      },
    },

  #[E](e: E): mut Flow[E] -> Error.msg "_PipelineParallelFlow# should not be reachable",
  }

//---File flows/converters.fear
package base.flows

Joinable[T,R]: {.join(flow: mut Flow[T]): R}
Joinable[T]: Joinable[T,T]{}

_RestrictFlowReuse: {
  #[E](flow: mut Flow[E]): mut Flow[E] -> Block#
    .var[Bool] isTail = {True}
    .return {{
      .unwrapOp(token) -> flow.unwrapOp(token),
      mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] ->
        Block#(_CheckFlowReuse#isTail, flow.actorMut[S,R](state, f)),
      mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] ->
        Block#(_CheckFlowReuse#isTail, flow.actor[S,R](state, f)),
      .first -> Block#(_CheckFlowReuse#isTail, flow.first),
      .filter(predicate) -> Block#(_CheckFlowReuse#isTail, flow.filter(predicate)),
      .findMap(f) -> Block#(_CheckFlowReuse#isTail, flow.findMap(f)),
      .flatMap(f) -> Block#(_CheckFlowReuse#isTail, flow.flatMap(f)),
      .fold(acc, f) -> Block#(_CheckFlowReuse#isTail, flow.fold(acc, f)),
      .limit(n) -> Block#(_CheckFlowReuse#isTail, flow.limit(n)),
      .map(f) -> Block#(_CheckFlowReuse#isTail, flow.map(f)),
      .map(ctx, f) -> Block#(_CheckFlowReuse#isTail, flow.map(ctx, f)),
      .with(other) -> Block#(_CheckFlowReuse#isTail, flow.with(other)),
      .size -> Block#(_CheckFlowReuse#isTail, flow.size),
    }},
  }
_CheckFlowReuse: {
  #(isTail: mut Var[Bool]): Void -> isTail.get ? {
    .then -> isTail := False,
    .else -> Error.msg "This flow cannot be reused. Consider collecting it to a list first.",
    },
  }

_MutSourceCollection[E]: {
  #(source: mut FlowOp[E]): mut Flow[E] -> Flow.fromOp(this.wrap(source)),
  #(source: mut FlowOp[E], size: Nat): mut Flow[E] -> Flow.fromOp(this.wrap(source), size),
  .wrap(source: mut FlowOp[E]): mut FlowOp[E] -> Block#
    .var[mut Opt[mut FlowOp[E]]] cloned = {{}}
    .return{{
      .isRunning -> this.get(cloned, source).isRunning,
      .stop -> this.get(cloned, source).stop,
      .step(downstream) -> this.get(cloned, source).step(downstream),
      }},
  .get(cloned: mut Var[mut Opt[mut FlowOp[E]]], original: mut FlowOp[E]): mut FlowOp[E] -> cloned.get.match{
     .some(cloned') -> cloned',
     .empty -> Block#
       .let[mut List[E]] dup = {Flow.fromOp(original).list}
       .do {cloned := (Opts#(Block#[mut FlowOp[E]]
         .let[mut Count[Nat]] cursor = {Count.nat(0)}
         .return {{'self
           .isRunning -> cursor* < (dup.size),
           .stop -> cursor := (dup.size),
           .step(downstream) -> dup.tryGet(cursor++).match{
             .some(x) -> Block#
               .do {downstream#x}
               .if {cursor.get >= (dup.size)} .do {Block#(downstream.stop, self.stop)}
               .return {{}},
             .empty -> Block#(downstream.stop, self.stop),
             },
           .for(downstream) -> Block#
             .loop {Block#
               .if {cursor.get >= (dup.size)} .return {Block#(downstream.stop, self.stop, ControlFlow.break)}
               .do {downstream#(dup.get(cursor++))}
               .return {ControlFlow.continue}
               }.return {{}},
           }}))}
       .return{cloned.get!},
     },
  }

_FlowConverters: Sealed{
  .range(start: Int, end: Int): mut Flow[Int] -> _FlowRange#(start, end),
  }
_FlowRange: {
  #(start: Int, end: Int): mut Flow[Int] -> Magic!,
  }

_SafeSource: {

  .fromList[E](list: mut List[E]): mut Flow[E] -> Flow.fromOp[E](this.fromList'[E](list, 0, list.size), list.size),
  .fromList'[E](list: mut List[E], start: Nat, end: Nat): mut FlowOp[E] -> Block#
    .let[mut Count[Nat]] cursor = {Count.nat(start)}
    .let[mut Count[Nat]] endCursor = {Count.nat(end)}
    .return {{'self
      .isRunning -> cursor* < (endCursor.get),
      .stop -> cursor := (endCursor.get),
      .step(downstream) -> cursor.get < (endCursor.get) ? {
        .then -> Block#
          .do {downstream#(list.get(cursor++))}
          .if {cursor.get >= (endCursor.get)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .else -> Block#(downstream.stop, self.stop),
        },
      .for(downstream) -> Block#
        .loop {Block#
          .if {cursor.get >= (endCursor.get)} .return {Block#(downstream.stop, self.stop, ControlFlow.break)}
          .do {downstream#(list.get(cursor++))}
          .return {ControlFlow.continue}
          }.return {{}},
      .split -> self.canSplit ? {
        .else -> {},
        .then -> Block#
          .let cur = {cursor.get}
          .let[Nat] mid = {cur + ((endCursor.get - cur) / 2)}
          .let[Nat] end' = {endCursor.swap(mid)}
          .return {Opts#(this.fromList'(list, mid, end'))},
        },
      .canSplit -> endCursor.get - (cursor.get) > 1,
      }},
  }

//---File flows/seq.fear
package base.flows

_SeqFlow: _FlowFactory{
  .fromOp[E](source: mut FlowOp[E], size: Opt[Nat]): mut Flow[E] -> _RestrictFlowReuse#{'self
    .unwrapOp(_) -> source,
    .filter(p) -> this.fromOp(_Filter#(_Sink, source, p), {}),

    .map(f) -> this.fromOp(_Map#(_Sink, source, f), size),
    .map(ctx, f) -> this.fromOp(_Map#(_Sink, source, ctx, f), size),

    .flatMap(f) -> this.fromOp(_FlatMap#(_Sink, source, f), {}),
    mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] ->
      this.fromOp(_Actor#[S,E,R](_Sink, source, state, f), {}),
    mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] ->
      this.fromOp(_Actor.anyRet[S,E,R](_Sink, source, state, f), {}),
    .limit(n) -> this.fromOp(_Limit#(_Sink, source, n), _LimitSize#(n, size)),
    .with(other) -> this.fromOp(_With#(_Sink, source, other.unwrapOp(mut _UnwrapFlowToken)), {}),

    mut .first: mut Opt[E] -> Block#
      .let[mut Var[mut Opt[E]]] res = {Vars#mut Opt[E]}
      .do {source.for(mut _Sink[E]{'runner
        .stop -> source.stop,
        .pushError(info) -> Error!info,
        #(e) -> res.get.isEmpty ? {
          .then -> Block#
            .do {res := (Opts#e)}
            .return {runner.stop},
          .else -> {},
          },
        })}
      .do {source.stop}
      .return {res.get},

    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> Block#
      .let[mut Var[mut Opt[R]]] res = {Vars#mut Opt[R]}
      .do {source.for(mut _Sink[E]{'runner
        .stop -> source.stop,
        .pushError(info) -> Error!info,
        #(e) -> res.get.isEmpty ? {
          .then -> f#e.match{
            .some(e') -> Block#
              .do{res := (Opts#e')}
              .return {runner.stop},
            .empty -> {},
            },
          .else -> {},
          },
        })}
      .do {source.stop}
      .return {res.get},

    mut .fold[S](acc: iso MF[S], f: read F[S,E,S]): S -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .openIso initialValueSupplier = acc
      .let[mut Var[S]] acc' = {Vars#(initialValueSupplier#)}
      .let stopped = {Vars#[Bool]False}
      .do {source.for(mut _Sink[E]{
        .stop -> stopped := True,
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        #(e) -> acc' := (f#(acc'.get, e)),
        })}
      .do {source.stop}
      .return {acc'.get},

    .size -> size.match{
      .some(n) -> n,
      .empty -> self.fold[Nat]({0}, {acc, _ -> acc + 1}),
      },
    },

  #[E](e: E): mut Flow[E] -> Block#
    .let[mut Var[mut Opt[E]]] seq = { Vars#(Opts#e) }
    .let[mut FlowOp[E]] source = {{'self
      .isRunning -> seq.get.isSome,
      .stop -> seq := {},
      .step(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, self.stop),
        },
      .for(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> Block#(downstream#x, downstream.stop, self.stop),
        .empty -> Block#(downstream.stop, self.stop),
        },
      }}
    .return {this.fromOp(source, Opts#1)},
  }

//---File flows/flowLet.fear
package base.flows

_LazyFlowDuplicators: {
  #[E](flow: mut Flow[E]): mut _LazyFlowDuplicator[E] -> Block#
    .var[mut Opt[mut List[E]]] collected = {mut Opt[mut List[E]]}
    .return {mut _LazyFlowDuplicator[E]: MF[mut Flow[E]]{
      # -> collected.get.match{
        .some(collected') -> collected'.flow,
        .empty -> Block#
          .let collected' = {flow.list}
          .do {collected := (Opts#collected')}
          .return {collected'.flow}
        },
      mut .collected: mut Opt[mut List[E]] -> collected*,
      }}
  }

//---File vars.fear
package base

Var:{
  #[X](x: X): mut Var[X] -> Block#
    .let[mut _MagicVarImpl[X]] inner = {_MagicVarImpl#x}
    .return {{
      .get -> inner.get,
      .swap(x') -> inner.swap(x'),
      }},
  }
Var[X:imm,mut,read]: Sealed{
  mut  .get: X,
  read .get: read/imm X,
  mut  *: X -> this.get,
  read *: read/imm X -> this.get,

  mut .swap(x: X): X,
  mut :=(x: X): Void -> Block#(this.swap(x)),
  mut .set(x: X): Void -> this := x,
  mut <-(f: mut UpdateVar[X]): X -> this.swap(f#(this*)),
  mut .update(f: mut UpdateVar[X]): X -> this <- f,
  }
UpdateVar[X]: { mut #(x: X): X }

Count[N:imm]: Var[N]{
  mut ++: N,
  mut --: N,
  mut +=(n: N): N,
  mut -=(n: N): N,
  mut *=(n: N): N,
  }
Count:{
  #(n: Int): mut Count[Int] -> this.int(n),
  .int(n: Int): mut Count[Int] -> Let#({
    .var -> Vars#n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + +1 },
      -- -> c <- { c' -> c' - +1 },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    }),
  .nat(n: Nat): mut Count[Nat] -> Let#({
    .var -> Vars#n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1 },
      -- -> c <- { c' -> c' - 1 },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    })
  }

_MagicVarImpl: {#[X](x: X): mut _MagicVarImpl[X] -> Magic!}
_MagicVarImpl[X]: {
  mut  .get: X,
  read .get: read/imm X,
  mut .swap(x: X): X,
  }

//---File nums.fear
package base

Int: Sealed,_MathOps[imm Int],_IntOps[imm Int]{}
Nat: Sealed,_MathOps[imm Nat],_IntOps[imm Nat],_UnsignedOps[imm Nat]{
  .offset(delta: Int): Nat,
  }
Byte: Sealed,_MathOps[imm Byte],_IntOps[imm Byte],_UnsignedOps[imm Byte]{
  .offset(delta: Int): Byte,
  }
Float: Sealed,_MathOps[imm Float]{
  .round: Int,
  .ceil: Int,
  .floor: Int,
  **(n: Float): Float, // pow
  .isNaN: Bool,
  .isInfinite: Bool,
  .isPosInfinity: Bool,
  .isNegInfinity: Bool,
  }

_MathOps[T]: Sealed{
  read .int: Int,
  read .nat: Nat,
  read .float: Float,
  read .byte: Byte,
  read .str: Str,
  +(n: T): T,
  -(n: T): T,
  *(n: T): T,
  /(n: T): T,
  %(n: T): T,
  .abs: T,

  >(n: T): Bool,
  <(n: T): Bool,
  >=(n: T): Bool,
  <=(n: T): Bool,
  ==(n: T): Bool,
  .assertEq(actual: T): Void,
  .assertEq(actual: T, message: Str): Void,
  read .hash(hasher: mut Hasher): Void,
  }
_IntOps[T]: Sealed{
  .shiftLeft(n: T): T,
  .shiftRight(n: T): T,
  .xor(n: T): T,
  .bitwiseAnd(n: T): T,
  .bitwiseOr(n: T): T,

  **(n: Nat): T, // pow
  }
_UnsignedOps[T]: Sealed{
  .offset(n: Int): T,
  }

_IntInstance: Int{
  .int -> Magic!,
  .nat -> Magic!,
  .float -> Magic!,
  .byte -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,

  .shiftLeft(n) -> Magic!,
  .shiftRight(n) -> Magic!,
  .xor(n) -> Magic!,
  .bitwiseAnd(n) -> Magic!,
  .bitwiseOr(n) -> Magic!,

  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  .assertEq(actual) -> Magic!,
  .assertEq(actual, message) -> Magic!,
  .hash(_) -> Magic!,
  }
_NatInstance: Nat{
  .int -> Magic!,
  .nat -> Magic!,
  .float -> Magic!,
  .byte -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .offset(n) -> Magic!,

  .shiftLeft(n) -> Magic!,
  .shiftRight(n) -> Magic!,
  .xor(n) -> Magic!,
  .bitwiseAnd(n) -> Magic!,
  .bitwiseOr(n) -> Magic!,

  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  .assertEq(actual) -> Magic!,
  .assertEq(actual, message) -> Magic!,
  .hash(_) -> Magic!,
  }
_ByteInstance: Byte{
  .int -> Magic!,
  .nat -> Magic!,
  .float -> Magic!,
  .byte -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .offset(n) -> Magic!,

  .shiftLeft(n) -> Magic!,
  .shiftRight(n) -> Magic!,
  .xor(n) -> Magic!,
  .bitwiseAnd(n) -> Magic!,
  .bitwiseOr(n) -> Magic!,

  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  .assertEq(actual) -> Magic!,
  .assertEq(actual, message) -> Magic!,
  .hash(_) -> Magic!,
  }
_FloatInstance: Float{
  .int -> Magic!,
  .nat -> Magic!,
  .float -> Magic!,
  .byte -> Magic!,
  .str -> Magic!,
  .round -> Magic!,
  .ceil -> Magic!,
  .floor -> Magic!,
  .isNaN -> Magic!,
  .isInfinite -> Magic!,
  .isPosInfinity -> Magic!,
  .isNegInfinity -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  .assertEq(actual) -> Magic!,
  .assertEq(actual, message) -> Magic!,
  .hash(_) -> Magic!,
  }

_NumsAssertionHelper[T]: {
  .assertEq(expected: T, actual: T): Void,
  .assertEq(expected: T, actual: T, message: Str): Void,
  }
_IntAssertionHelper: _NumsAssertionHelper[Int]{
  .assertEq(expected, actual) ->
    Assert!(expected == actual, "Expected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  .assertEq(expected, actual, message) ->
    Assert!(expected == actual, message+"\nExpected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  }
_NatAssertionHelper: _NumsAssertionHelper[Nat]{
  .assertEq(expected, actual) ->
    Assert!(expected == actual, "Expected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  .assertEq(expected, actual, message) ->
    Assert!(expected == actual, message+"\nExpected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  }
_ByteAssertionHelper: _NumsAssertionHelper[Byte]{
  .assertEq(expected, actual) ->
    Assert!(expected == actual, "Expected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  .assertEq(expected, actual, message) ->
    Assert!(expected == actual, message+"\nExpected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  }
_FloatAssertionHelper: _NumsAssertionHelper[Float]{
  .assertEq(expected, actual) ->
    Assert!(expected == actual, "Expected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  .assertEq(expected, actual, message) ->
    Assert!(expected == actual, message+"\nExpected: "+(expected.str)+"\nActual: "+(actual.str), {{}}),
  }

//---File iter/pkg.fear
package base.iter
alias base.LList as LList, alias base.List as List,
alias base.Opts as Opts, alias base.Opt as Opt, alias base.OptMap as OptMap, alias base.OptMatch as OptMatch,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Nat as Nat, alias base.Int as Int, alias base.Float as Float,
alias base.Str as Str,
alias base.Let as Let,
alias base.Block as Block, alias base.ReturnStmt as ReturnStmt,
alias base.Var as Var,
alias base.Sealed as Sealed,

//---File iter/iter.fear
package base.iter

Iter[E]:{
  mut .next: mut Opt[E],
  mut .find(p: mut IterPredicate[E]): mut Opt[E] -> this.next.match[mut Opt[E]]{
    .some(x) -> p#x ? { .then -> Opts#x, .else -> this.find(p) },
    .empty -> {}
    },
  mut .allMatch(p: mut IterPredicate[E]): Bool -> this.find{x -> p#x .not}.match[Bool]{
    .some(_) -> False,
    .empty -> True
    },
  mut .anyMatch(p: mut IterPredicate[E]): Bool -> this.find(p).match[Bool]{
    .some(_) -> True,
    .empty -> False
    },

  mut .map[R](f: mut IterMapper[E, R]): mut Iter[R] -> { this.next.map[R](f) },
  mut .flatMap[R](f: mut IterMapper[E, mut Iter[R]]): mut Iter[R] -> Block#
    .let[mut Iter[mut Iter[R]]] mapIter = { this.map(f) }
    .let[mut Var[mut Opt[mut Iter[R]]]] optCurIter = { Vars#(mapIter.next) }
    .return(mut ReturnStmt[mut Iter[R]]{ mut Iter[R]{ 'self
      .next -> optCurIter*[].match[mut Opt[R]]{
        .some(curIter) -> curIter.next.match[mut Opt[R]]{
          .some(next) -> Opts#next,
          .empty -> Block#(optCurIter := (mapIter.next), self.next)
          },
        .empty -> {}
        }
      }}),
  mut .filter(p: mut IterPredicate[E]): mut Iter[E] -> { .next -> this.find(p) },

  mut .fold[R](acc: R, f: mut IterFolder[E, R]): R -> this.next.match[R]{
    .some(e) -> this.fold(f#(acc, e), f),
    .empty -> acc
    },
  mut .for(f: mut IterForEacher[E]): Void -> this.next.match[Void]{
    .some(e) -> Block#(f#e, this.for(f)),
    .empty -> {}
    },

  mut .count: Nat -> this.fold[Nat](0, mut IterFolder[E, Nat]{ acc, _ -> acc + 1 }),
  mut .list: mut List[E] -> this.fold(List#[E], { acc, e -> Block#(acc.add(e), acc) }),
  mut .llist: mut LList[E] -> this.fold(mut LList[E], { acc, e -> acc +[] e }),
  mut .str(toStr: mut IterMapper[E, Str], joining: Str): Str -> this.map(toStr)
    .fold[Str]("", mut IterFolder[Str, Str]{acc, e -> acc.isEmpty ? {
      .then -> acc + e,
      .else -> acc + joining + e }
      }).str,
  }

Sum:{
  .int(ns: mut Iter[Int]): Int -> ns.fold[Int](+0, mut IterFolder[Int, Int]{ acc, n -> acc + n }),
  .nat(ns: mut Iter[Nat]): Nat -> ns.fold[Nat](0, mut IterFolder[Nat, Nat]{ acc, n -> acc + n }),
  .float(ns: mut Iter[Float]): Float -> ns.fold[Float](0.0, mut IterFolder[Float, Float]{ acc, n -> acc + n }),
  }

IterForEacher[E]:{ mut #(e: E): Void }
IterFolder[E,R]:{ mut #(acc: R, e: E): R }
IterScanner[E, R, S]:{ mut #(state: mut Var[S], e: E): S }
IterMapper[E,R]:OptMap[E, R]
IterPredicate[E]:{ mut #(e: E): Bool }


//---File iter/flows.fear
package base.iter

alias base.flows.Flow as Flow,
alias base.flows.FlowOp as FlowOp,
alias base.flows.ControlFlow as FlowCtrl,
alias base.flows._Sink as FlowSink,

//---File iter/automatons.fear
package base.iter.automatons
alias base.F as F,
alias base.Opt as Opt,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Let as Let,
alias base.Block as Block,



//---File lang.fear
package base
alias base.caps.System as System,

Main: { #(s: mut System): Void }
Sealed: {}
Void: Sealed{}

Abort: Sealed{![R:readH,mutH,read,mut,imm,iso]: R -> this!} // can be optimised to just terminate (goes stuck)
Magic: Sealed{
  ![R:readH,mutH,read,mut,imm,iso]: R -> this!, // magic'd out to tell us what we forgot to implement
  ![R:readH,mutH,read,mut,imm,iso](_: mut base.caps._System): R -> this!,
  }
Debug: Sealed{
  #[T](x: T): T -> x,
  .println[T](x: T): Void -> {},
  .identify[T](x: T): Str -> Magic!,
  }
HasIdentity: { mut .idEq(other: readH HasIdentity): Bool -> Magic! } // TODO: magic

As[X:imm,mut,read,iso]: Sealed{ #(x: X): X -> x }

Let: {
  #[V,R](l: mut Let[V, R]): R -> l.in(l.var),
  }
Let[V,R]: { mut .var: V, mut .in(v: V): R }

F[R:read,mut,imm,iso]: { read #: R }
F[A:read,mut,imm,iso,R:read,mut,imm,iso]: { read #(a: A): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B, c: C): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, D:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B, c: C, d: D): R }

MF[R:read,mut,imm,iso]: { mut #: R }
MF[A:read,mut,imm,iso,R:read,mut,imm,iso]: { mut #(a: A): R }
MF[A:read,mut,imm,iso, B:read,mut,imm,iso, R:read,mut,imm,iso]: { mut #(a: A, b: B): R }
MF[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, R:read,mut,imm,iso]: { mut #(a: A, b: B, c: C): R }
MF[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, D:read,mut,imm,iso, R:read,mut,imm,iso]: { mut #(a: A, b: B, c: C, d: D): R }

Consumer[A:read,mut,imm,iso]: { mut #(a: A): Void }
Consumer[A:read,mut,imm,iso, B:read,mut,imm,iso]: { mut #(a: A, b: B): Void }
Consumer[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso]: { mut #(a: A, b: B, c: C): Void }

ToImm[R]: {read .toImm: imm R}
ToIso[R]: {mut .iso: iso ToIso[R], mut .self: mut R,}

Box[T]: {
  mut  .get: T,
  read .get: read/imm T,
  imm  .get: imm T,
  }

//---File rng.fear
package base.rng
alias base.Block as Block,
alias base.Nat as Nat, alias base.Float as Float,
alias base.F as F,
alias base.Infos as Infos,
alias base.Sealed as Sealed,
alias base.Var as Var, alias base.VarImm as VarImm,

FRandom: F[Nat, mut Random]{seed -> Block#
  .if {seed == 0} .error {Infos.msg "Seed may not be zero"}
  .let prev = {Vars#seed}
  .return {{
    .nat -> Block#
      .do {prev := ((prev.get) * 6364136223846793005 + 1 .shiftRight 33)}
      .return {prev.get},
    }}
  }
Random: {
  mut .nat: Nat,
  mut .nat(minInclusive: Nat, maxExclusive: Nat): Nat -> Block#
     .assert({minInclusive <= maxExclusive}, "Cannot generate a random number, "+(minInclusive.str)+" is greater than "+(maxExclusive.str))
     .return {(this.float * (maxExclusive.float - (minInclusive.float)) + (minInclusive.float)).floor.nat},

  mut .float: Float -> this.nat.float / 2147483647.0,
  }

//---File blocks.fear
package base

ReturnStmt[R]: {mut #: R}
Condition: ReturnStmt[Bool]
LoopBody[R]: ReturnStmt[mut ControlFlow[R]]
Continuation[T,C,R]: {mut #(x: T, self: C): R}
ControlFlow: {
  .continue: mut ControlFlow[Void] -> mut ControlFlowContinue: ControlFlow[Void]{m -> m.continue},
  .break: mut ControlFlow[Void] -> mut ControlFlowBreak: ControlFlow[Void]{m -> m.break},
  .continueWith[T]: mut ControlFlow[T] ->  mut ControlFlowContinue[T]: ControlFlow[T]{m -> m.continue},
  .breakWith[T]: mut ControlFlow[T] -> mut ControlFlowBreak[T]: ControlFlow[T]{m -> m.break},
  .return[T](returnValue: T): mut ControlFlow[T] -> mut ControlFlowReturn[T]: ControlFlow[T]{
    .match(m) -> m.return(returnValue),
    mut .value: T -> returnValue,
    },
  }
ControlFlow[T]: {
  mut .match[R](m: mut ControlFlowMatch[T,R]): R,
  }
ControlFlowMatch[T,R]: {
  mut .continue: R,
  mut .break: R,
  mut .return(returnValue: T): R,
  }

Block: Sealed{
  #[R]: mut Block[R] -> {},
  #[X:read,mut,imm,iso,readH,mutH](x: X): Void -> this#(x, Void),
  #[X:read,mut,imm,iso,readH,mutH, R:read,mut,imm,iso,readH,mutH](_: X, res: R): R -> res,
  #[X1:read,mut,imm,iso,readH,mutH, X2:read,mut,imm,iso,readH,mutH, R:read,mut,imm,iso,readH,mutH](_: X1, _: X2, res: R): R -> res,
  #[X1:read,mut,imm,iso,readH,mutH, X2:read,mut,imm,iso,readH,mutH, X3:read,mut,imm,iso,readH,mutH, R:read,mut,imm,iso,readH,mutH](_: X1, _: X2, _: X3, res: R): R -> res,
  #[X1:read,mut,imm,iso,readH,mutH, X2:read,mut,imm,iso,readH,mutH, X3:read,mut,imm,iso,readH,mutH, X4:read,mut,imm,iso,readH,mutH, R:read,mut,imm,iso,readH,mutH](_: X1, _: X2, _: X3, _: X4, res: R): R -> res,
  }
Block[R]: Sealed{
  mut .done: Void -> {},
  mut .return(a: mut ReturnStmt[R]): R -> a#,
  mut .do(r: mut ReturnStmt[Void]): mut Block[R] -> this._do(r#),
    mut ._do(v: Void): mut Block[R] -> this,
  mut .assert(p: mut Condition): mut Block[R] -> Assert!(p#, mut AssertCont[mut Block[R]]{this}),
  mut .assert(p: mut Condition, failMsg: Str): mut Block[R] ->
    Assert!(p#, failMsg, mut AssertCont[mut Block[R]]{this}),
  mut .let[X](x: mut ReturnStmt[X], cont: mut Continuation[X, mut Block[R], R]): R -> cont#(x#, this),
  mut .openIso[X:iso,imm,mut,read](x: iso X, cont: mut Continuation[mut X, mut Block[R], R]): R -> cont#(x, this),
  mut .var[X](x: mut ReturnStmt[X], cont: mut Continuation[mut Var[X], mut Block[R], R]): R -> cont#(Vars#(x#), this),
  mut .if(p: mut Condition): mut BlockIf[R] -> p# ? { 'cond
    .then -> { 't
      .return(a) -> _DecidedBlock#(a#),
      .error(info) -> Error!(info#),
      .do(r) -> t._do[](r#),
        mut ._do(v: Void): mut Block[R] -> this,
      },
    .else -> { 'f
      .return(_) -> this,
      .do(_) -> this,
      .error(_) -> this,
      },
    },
  mut .loop(body: mut LoopBody[R]): mut Block[R] -> body#.match{
    .continue -> this.loop(body),
    .break -> this,
    .return(rv) -> _DecidedBlock#rv,
    },
  }
BlockIf[R]:{
  mut .return(a: mut ReturnStmt[R]): mut Block[R],
  mut .do(r: mut ReturnStmt[Void]): mut Block[R],
  mut .error(info: mut ReturnStmt[Info]): mut Block[R],
  }
_DecidedBlock:{
  #[R](res: R): mut Block[R] -> { 'self
    .return(_) -> res,
    .do(_) -> self,
    .let(_, _) -> res,
    .openIso(_, _) -> res,
    .var(_, _) -> res,
    .assert(_) -> self,
    .assert(_, _) -> self,
    .if(_) -> {
      .return(_) -> self,
      .do(_) -> self,
      .error(_) -> self,
      },
    .loop(_) -> self,
    }
  }

//---File errors.fear
package base

Error: {
  ![R:read,mut,imm,iso,mutH,readH](info: Info): R -> Magic!,
  .msg[R:read,mut,imm,iso,mutH,readH](msg: Str): R -> this!(Infos.msg msg)
  }

Todo: {
  ![R:read,mut,imm,iso,mutH,readH]: R -> Error.msg[R] "TODO: Implement this code",
  ![R:read,mut,imm,iso,mutH,readH](msg: Str): R -> Error.msg[R]("TODO: " + msg),
  }

Unreachable: {
  ![R:read,mut,imm,iso,mutH,readH]: R -> Error.msg[R] "Unreachable code reached",
  ![R:read,mut,imm,iso,mutH,readH](msg: Str): R -> Error.msg[R]("Unreachable code reached: " + msg),
  }

Try: {
  #[R](try: read F[R]): mut Action[R] -> Magic!,
  #[T:iso,imm,mut,read,R](data: iso T, try: read F[iso T, R]): mut Action[R] -> Magic!,
  }

Info: Sealed{
  .msg: Str,
  .map: LinkedHashMap[Str, Info],
  .list: List[Info],
  .accept[R](visitor: InfoVisitor[R]): R,
  .str: Str -> this.accept[Json](_InfoToJson).str,
  }
Infos: {
  .msg(msg: Str): Info -> {'info
    .msg -> msg,
    .list -> List#,
    .map -> Maps.hashMap({k1, k2 -> k1 == k2}, {k -> k}),
    .accept(visitor) -> visitor.msg(info),
    },
  .list(list: List[Info]): Info -> {'info
    .msg -> "",
    .list -> list,
    .map -> Maps.hashMap({k1, k2 -> k1 == k2}, {k -> k}),
    .accept(visitor) -> visitor.list(info),
    },
  .map(map: LinkedHashMap[Str, Info]): Info -> {'info
    .msg -> "",
    .list -> List#,
    .map -> map,
    .accept(visitor) -> visitor.map(info),
    },
  }
InfoVisitor[R]: {
  .msg(info: Info): R,
  .list(info: Info): R,
  .map(info: Info): R,
  }

_InfoToJson: InfoVisitor[Json]{
  .msg(info) -> Jsons.string(info.msg),
  .list(info) -> Jsons.array(info.list.flow.map{info' -> info'.accept(this)}.list),
  .map(info) -> Jsons.object(info.map.flow
    .map{kv -> Entry[Str,Json]{
      .key -> kv.key,
      .value -> kv.value.accept(this),
      }}
    .fold(
      {Maps.hashMap[Str,Json]({k1, k2 -> k1 == k2}, {k -> k})},
      {acc, kv -> acc + (kv.key, kv.value)}
      )
    ),
  }

//---File caps/net.fear
package base.caps.net
alias base.Magic as Magic,
alias base.Sealed as Sealed,


//---File caps/env.fear
package base.caps

Env: ToIso[Env]{
  mut .launchArgs: base.LList[Str],
  }

FEnv:F[mut System, mut Env],Sealed{
  #(s) -> s.io.env,
  .io(io: mut IO): mut Env -> io.env,
  }

//---File caps/pkg.fear
package base.caps
alias base.Abort as Abort,
alias base.Magic as Magic,
alias base.Void as Void,
alias base.F as F,
alias base.Sealed as Sealed,
alias base.Str as Str,
alias base.Let as Let,
alias base.Stringable as Stringable,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Block as Block,
alias base.Nat as Nat,
alias base.Res as Res,
alias base.Info as Info,
alias base.Infos as Infos,
alias base.Actions as Actions,
alias base.Action as Action,
alias base.ToIso as ToIso,

//---File caps/io.fear
package base.caps
alias base.List[base.Str] as Path,

IO: ToIso[IO]{
  mut .print(msg: Str): Void,
  mut .println(msg: Str): Void,
  mut .printErr(msg: Str): Void,
  mut .printlnErr(msg: Str): Void,
  mut .accessR(path: Path): mut ReadPath,
  mut .accessW(path: Path): mut WritePath,
  mut .accessRW(path: Path): mut ReadWritePath,
  mut .env: mut Env,
  mut .iso: iso IO,
  }
UnrestrictedIO: F[mut System, mut IO],Sealed{sys -> sys.io}

ReadPath: _ReadPath,ToIso[ReadPath]{}
_ReadPath: {
  mut .accessR(path: Path): mut ReadPath,
  mut .readStr: mut Action[Str],
  }
WritePath: _WritePath,ToIso[WritePath]{}
_WritePath: {
  mut .accessW(path: Path): mut WritePath,
  }
ReadWritePath: _ReadPath,_WritePath,ToIso[ReadWritePath]{
  mut .accessRW(path: Path): mut ReadWritePath,
  }

FileHandleMode:Stringable,Sealed{}
Read:FileHandleMode{ "r" }
Write:FileHandleMode{ "r+" }
Create:FileHandleMode{ "w+" }

//---File caps/capabilities.fear
package base.caps

System: ToIso[System]{
  mut .io: mut IO,
  mut .rng: mut RandomSeed,
  mut .try: mut CapTry,
  }
_System: Sealed,System{
  .iso -> iso _System,
  .self -> this,
  .io -> Magic!this,
  .rng -> Magic!this,
  .try -> Magic!this,
  }

//---File caps/isopod.fear
package base.caps

IsoPod:{
  #[T:imm,iso](val: iso T): mut IsoPod[iso T] -> _MagicIsoPodImpl.toIsoPod[iso T](_MagicIsoPodImpl#[iso T](val)),
  }
IsoPod[T:imm,iso]: {
  read .isAlive: Bool,
  read .peek[R](f: mut IsoViewer[T, R]): R,
  read .look[R](f: mut IsoViewer'[T, R]): mut Action[R] -> {m -> this.peek{
    .some(x) -> m.ok(f#x),
    .empty -> m.info(Infos.msg "The IsoPod was empty"),
    }},
  mut !: iso T,
  mut .next(val: iso T): Void,
  read .isDead: Bool -> this.isAlive.not,
  mut .consume[R](f: mut IsoConsumer[T, R]): R -> this.isAlive ? { .then -> f.some(this!), .else -> f.empty },
  mut :=(val: iso T): Void -> this.next(val),
  mut .mutate(f: F[mut T, Void]): mut Action[Void] -> {m -> this.consume{
    .some(x) -> Block#(this.next(_IsoMutator#(f, x)), m.ok{}),
    .empty -> m.info(Infos.msg "The IsoPod was empty"),
    }}
  }
IsoConsumer[T:imm,iso, R]:{
  mut .some(x: iso T): R,
  mut .empty: R,
  }
IsoViewer[T:imm,iso, R]:{
  mut .some(x: readH T): R,
  mut .empty: R,
  }
IsoViewer'[T:imm,iso, R]:{
  mut #(x: readH T): R,
  }
_IsoMutator:{ #[T,R](f: F[mut T, R], val: mut T): mut T -> Block#(f#val, val) }

_MagicIsoPodImpl: {
  #[T:iso](val: iso T): mut _MagicIsoPodImpl[iso T] -> Magic!,
  .toIsoPod[T:iso](inner: mut _MagicIsoPodImpl[iso T]): mut IsoPod[iso T] -> {
    read .isAlive: Bool -> inner.isAlive,
    read .peek[R](f: mut IsoViewer[iso T, R]): R -> inner.peek[R](f),
    mut !: iso T -> inner!,
    mut .next(val: iso T): Void -> inner.next(val),
    },
  }
_MagicIsoPodImpl[T:imm,iso]: {
  read .isAlive: Bool -> Magic!,
  read .peek[R](f: mut IsoViewer[T, R]): R -> Magic!,
  mut !: iso T -> Magic!,
  mut .next(val: iso T): Void -> Magic!,
  }


//---File caps/rng.fear
package base.caps

RandomSeed: ToIso[RandomSeed]{
  mut #: Nat,
  }

//---File caps/tryCatch.fear
package base.caps

CapTry: ToIso[CapTry]{
  mut #[R](try: read F[R]): mut Action[R],
  mut #[T:iso,imm,mut,read,R](data: iso T, try: read F[iso T, R]): mut Action[R],
  }
CapTrys: F[mut System, mut CapTry]{sys -> sys.try}

//---File extensions.fear
package base

Extensible[S]:{
  mut  .self: mut  S,
  read .self: read S,
  imm  .self: imm  S,

  mut  #[R](ext: mut Extension[mut  S, R]): R -> ext#(this.self),
  read #[R](ext: mut Extension[read S, R]): R -> ext#(this.self),
  imm  #[R](ext: mut Extension[imm  S, R]): R -> ext#(this.self),
  }
Extension[S,R]:{ mut #(self: S): R }

