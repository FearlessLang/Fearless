package base

Opt:{ #[T](x: T): Opt[T] -> { .match(m) -> m.some(x) } }
Opt[T]:{
  .match[R](m: OptMatch[T, R]): R -> m.none,
  .map[R](f: OptMap[T,R]): Opt[R] -> this.match(f),
  .do(f: OptDo[T]): Opt[T] -> this.match(f),
  .flatMap[R](f: OptFlatMap[T, R]): Opt[R] ->this.match(f),
  ||(alt: T): T -> this.match{ .some(x) -> x, .none -> alt },
  .isNone: Bool -> this.match{ .none -> True, .some(_) -> False },
  .isSome: Bool -> this.match{ .none -> False, .some(_) -> True },
  }
OptMatch[T,R]:{ .some(x:T): R, .none: R }
OptFlatMap[T,R]:OptMatch[T,Opt[R]]{ .none -> {} }
OptMap[T,R]:OptMatch[T,Opt[R]]{ #(t:T):R, .some(x) -> Opt#(this#x), .none -> {} }
OptDo[T]:OptMatch[T,Opt[T]]{
  #(t:T):Void,   //#[R](t:T):R,
  .some(x) -> Opt#(this._doRes(this#x, x)),
  .none->{},
  ._doRes(y:Void,x:T):T -> x
  }
