package base.caps

IsoPod:{ #[T](val: iso T): mut IsoPod[T] -> base.Abort! } // magic
IsoPod[T]:{
  read .isAlive: Bool, // magic
  read .isDead: Bool -> this.isAlive.not,
  read .peek[R](f: mut IsoViewer[T, mdf R]): mdf R, // magic
  read .peekHyg[R](f: lent IsoViewerHyg[T, mdf R]): mdf R, // magic
  lent .consume: iso T, // magic
  lent *: iso T -> this.consume,
  lent .next(val: iso T): Void, // magic
  lent :=(val: iso T): Void -> this.next(val),
  lent .mutate(f: F[mut T, Void]): Void -> this.next(IsoMutator#(f, this.consume)),
  }
IsoMutator:{ #[T,R](f: F[mut T, R], val: mut T): mut T -> Yeet.with(f#val, val) }
IsoViewer[T,R]:{
  mut .some(x: read T): mdf R,
  mut .none: mdf R,
  }
IsoViewerHyg[T,R]:{
  lent .some(x: read T): mdf R,
  lent .none: mdf R,
  }

// TODO The idea:
//IsoPod[T]:{
//  mut .consume:iso T,
//  mut .update(val: iso T):Void,
//  read .observe[R](obs:mut Observer[T,mdf R]):mdf R->..,
//  mut .change[R](f:F[mut T, R]):imm R->consume, call f, update back
//  read .spawn(f:F[read T,mdf R])->Node[??]{f=ff, self=this} + add a
//ref to the result to a list of spawn
//   //every time we call update OR change we do something for all the
//spowened: lazy/now/eager
//
//  }
//Observer[T,R]:{ mut #(content:read T):mdf R }
//F[read T]
//Node[T,R]:{ }