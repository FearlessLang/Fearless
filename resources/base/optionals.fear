package base

Opt:{ #[T](x: mdf T): mut Opt[mdf T] -> {
  .match(m) -> m.some(x),
  .matchHyg(m) -> m.some(x),
  .matchMut(m) -> m.some(x)
  }}
Opt[T]:NoMutHyg[mdf T]{
  read .match[R](m: mut OptMatch[recMdf T, mdf R]): mdf R -> m.none,
  mut  .matchMut[R](m: mut OptMatch[mdf T, mdf R]): mdf R -> m.none,
  read .matchHyg[R](m: recMdf OptMatchHyg[recMdf T, mdf R]): mdf R -> m.none,
  read .map[R](f: mut OptMap[recMdf T, mdf R]): mut Opt[mdf R] -> this.match{ .some(x) -> Opt#(f#x), .none -> {} },
  read .flatMap[R](f: mut OptMap[recMdf T, recMdf Opt[mdf R]]): mut Opt[mdf R] -> this.match{ .some(x) -> f#x, .none -> {} },
  read .do(f: mut OptMap[recMdf T, Void]): mut Opt[recMdf T] -> Yeet.with(this.map(f), this.map{ x -> x }),
  read |(alt: recMdf T): recMdf T -> this.matchHyg{ .some(x) -> x, .none -> alt },
  read ||(alt: recMdf Box[recMdf T]): recMdf T -> this.matchHyg{ .some(x) -> x, .none -> alt# },
  read .isNone: Bool -> this.match{ .none -> True, .some(_) -> False },
  read .isSome: Bool -> this.match{ .none -> False, .some(_) -> True },
  }
OptMatch[T,R]:NoMutHyg[mdf R]{ mut .some(x: mdf T): mdf R, mut .none: mdf R }
OptMatchHyg[T,R]:NoMutHyg[mdf R]{ read .some(x: mdf T): mdf R, read .none: mdf R }
OptMap[T,R]:{ mut #(x: mdf T): mdf R }
