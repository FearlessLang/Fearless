package base

Opt:{ #[T](x: mdf T): mut Opt[mdf T] -> {
  .match(m) -> m.some(x),
  .matchHyg(m) -> m.some(x),
  .orMatchHyg(m) -> m.some(x),
  }}
Opt[T]:NoMutHyg[mdf T]{
  read .match[R](m: mut OptMatch[recMdf T, mdf R]): mdf R -> m.none,
  read .matchHyg[R](m: recMdf OptMatchHyg[recMdf T, mdf R]): mdf R -> m.none,
  read .orMatchHyg[R](m: recMdf OrOptMatchHyg[recMdf T, mdf R]): recMdf R -> m.none,
  read .map[R](f: mut OptMap[recMdf T, mdf R]): mut Opt[mdf R] -> this.match{ .some(x) -> Opt#(f#x), .none -> {} },

  // recMdf used in the mut .some method, would not be allowed
//  read .map[R](f: mut OptMap[recMdf T, mdf R]): mut Opt[mdf R] -> this.match(mut OptMatch[recMdf T, mdf R]{
//    mut .some(x: recMdf T): mut Opt[mdf R] -> Opt#(f#x),
//    mut .none: mut Opt[mdf R] -> {}
//    }),

  read .flatMap[R](f: mut OptMap[recMdf T, recMdf Opt[mdf R]]): mut Opt[mdf R] -> this.match{ .some(x) -> f#x, .none -> {} },
  read .do(f: mut OptMap[recMdf T, Void]): mut Opt[recMdf T] -> Yeet.with(this.map(f), this.map{ x -> x }),
  read |(alt: recMdf T): recMdf T -> this.matchHyg{ .some(x) -> x, .none -> alt },
  read .altOr(alt: recMdf T): recMdf T -> this.orMatchHyg(OrOptMatchHyg#alt),
  read ||(alt: recMdf Box[recMdf T]): recMdf T -> this.matchHyg{ .some(x) -> x, .none -> alt# },
  read .isNone: Bool -> this.match{ .none -> True, .some(_) -> False },
  read .isSome: Bool -> this.match{ .none -> False, .some(_) -> True },
  }
OptMatch[T,R]:NoMutHyg[mdf R]{ mut .some(x: mdf T): mdf R, mut .none: mdf R }
OptMatchHyg[T,R]:NoMutHyg[mdf R]{ read .some(x: mdf T): mdf R, read .none: mdf R }
OrOptMatchHyg[T,R]{ read .some(x: mdf T): mdf R, read .none: mdf R }
OrOptMatchHyg:{ #[T](alt:mdf T):lent OrOptMatchHyg[mdf T,mdf T]->{
  lent .some(x: mdf T): mdf T -> x,//foo#x
  lent .none: mdf T -> alt
  }}
OptMap[T,R]:{ mut #(x: mdf T): mdf R }
