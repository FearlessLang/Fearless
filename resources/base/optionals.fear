package base

Opt:{ #[T](x: mdf T): mut Opt[mdf T] -> {
   .match(m) -> m.some(x),
//  mut .match[R](m: mut OptMatch[mdf T, mdf R]): mdf R -> m.some(x),
//  read .match[R](m: mut OptMatch[read T, mdf R]): mdf R -> m.some(x),
//  // imm case is needed because the read one will return read E even if E is imm
//  imm  .match[R](m: mut OptMatch[T, mdf R]): mdf R -> m.some(x),
  }}
Opt[T]:{
  mut  .match[R](m: mut OptMatch[mdf T, mdf R]): mdf R -> m.empty,
  read .match[R](m: mut OptMatch[read T, mdf R]): mdf R -> m.empty,
  imm  .match[R](m: mut OptMatch[T, mdf R]): mdf R -> m.empty,

  mut  !: mdf T -> this.match[mdf T](mut OptMatch[mdf T, mdf T]{ .some(x) -> x, .empty -> Error.str "Opt was empty" }),
  read !: read T -> this.match[read T](mut OptMatch[read T, read T]{ .some(x) -> x, .empty -> Error.str "Opt was empty" }),
  imm  !: T -> this.match[T](mut OptMatch[T, T]{ .some(x) -> x, .empty -> Error.str "Opt was empty" }),

  mut .map[R](f: mut OptMap[mdf T, mdf R]): mut Opt[mdf R] -> this.match[mut Opt[mdf R]](f),
  read .map[R](f: mut OptMap[read T, mdf R]): mut Opt[mdf R] -> this.match[mut Opt[mdf R]](f),
  imm  .map[R](f: mut OptMap[T, mdf R]): mut Opt[mdf R] -> this.match[mut Opt[mdf R]](f),

  mut |(alt: mdf T): mdf T -> this.match[mdf T](mut OptMatch[mdf T, mdf T]{
    .some(x) -> x,
    .empty -> alt
    }),
  read |(alt: read T): read T -> this.match[read T](mut OptMatch[read T, read T]{
    .some(x) -> x,
    .empty -> alt
    }),
  imm  |(alt: T): T -> this.match[T](mut OptMatch[T, T]{
      .some(x) -> x,
      .empty -> alt
      }),

  mut  ||(alt: mut OptOrElse[mdf T]): mdf T -> this.match[mdf T](mut OptMatch[mdf T, mdf T]{
    .some(x) -> x,
    .empty -> alt#
    }),
  read ||(alt: mut OptOrElse[read T]): read T -> this.match[read T](mut OptMatch[read T, read T]{
    .some(x) -> x,
    .empty -> alt#
    }),
  imm ||(alt: mut OptOrElse[T]): T -> this.match[T](mut OptMatch[T, T]{
    .some(x) -> x,
    .empty -> alt#
    }),

//  mut .or(f: mut OptOrElse[mut Opt[mdf T]]): mut Opt[mdf T] -> this.match[mut Opt[mdf T]](mut OptMatch[mdf T, mut Opt[mdf T]]{
//    .some(x) -> this,
//    .empty -> f#
//    }),
  // TODO: this is the method that breaks the adapter ok check for imm Opt[read T] < imm Opt[imm T]
//  read .or(f: mut OptOrElse[read Opt[mdf T]]): read Opt[mdf T] -> this.match[read Opt[mdf T]](mut OptMatch[read T, read Opt[mdf T]]{
//    .some(x) -> this,
//    .empty -> f#
//    }),
//  imm .or(f: mut OptOrElse[Opt[T]]): Opt[T] -> this.match[Opt[T]](mut OptMatch[T, Opt[T]]{
//      .some(x) -> this,
//      .empty -> f#
//      }),

  read .isEmpty: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> True, .some(_) -> False }),
  read .isSome: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> False, .some(_) -> True }),
  }

OptMatch[T,R]:{ mut .some(x: mdf T): mdf R, mut .empty: mdf R }
OptOrElse[R]:{ mut #: mdf R }
OptMap[T,R]:OptMatch[mdf T, mut Opt[mdf R]]{
  mut #(t: mdf T): mdf R,
  .some(x) -> Opt#(this#x),
  .empty -> {}
  }
