package base

Opt:{ #[T](x: T): mut Opt[T] -> {
   .match(m) -> m.some(x),
//  mut .match[R](m: mut OptMatch[T, R]): R -> m.some(x),
//  read .match[R](m: mut OptMatch[read T, R]): R -> m.some(x),
//  // imm case is needed because the read one will return read E even if E is imm
//  imm  .match[R](m: mut OptMatch[T, R]): R -> m.some(x),
  }}
Opt[T]:Extensible[Opt[T]]{
  .self -> this,
  mut  .match[R](m: mut OptMatch[T, R]): R -> m.empty,
  read .match[R](m: mut OptMatch[read T, R]): R -> m.empty,
  imm  .match[R](m: mut OptMatch[imm T, R]): R -> m.empty,

  mut  !: T -> this.match[T](mut OptMatch[T, T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),
  read !: read T -> this.match[read T](mut OptMatch[read T, read T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),
  imm  !: imm T -> this.match[imm T](mut OptMatch[imm T, imm T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),

  mut .map[R](f: mut OptMap[T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),
  read .map[R](f: mut OptMap[read T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),
  imm  .map[R](f: mut OptMap[imm T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),

//  mut |(alt: T): T -> this.match[T](mut OptMatch[T, T]{
//    .some(x) -> x,
//    .empty -> alt
//    }),
//  read |(alt: read T): read T -> this.match[read T](mut OptMatch[read T, read T]{
//    .some(x) -> x,
//    .empty -> alt
//    }),
//  imm  |(alt: T): T -> this.match[T](mut OptMatch[T, T]{
//      .some(x) -> x,
//      .empty -> alt
//      }),
//
//  mut  ||(alt: mut OptOrElse[T]): T -> this.match[T](mut OptMatch[T, T]{
//    .some(x) -> x,
//    .empty -> alt#
//    }),
//  read ||(alt: mut OptOrElse[read T]): read T -> this.match[read T](mut OptMatch[read T, read T]{
//    .some(x) -> x,
//    .empty -> alt#
//    }),
//  imm ||(alt: mut OptOrElse[T]): T -> this.match[T](mut OptMatch[T, T]{
//    .some(x) -> x,
//    .empty -> alt#
//    }),
//
//  mut .or(f: mut OptOrElse[mut Opt[T]]): mut Opt[T] -> this.match[mut Opt[T]](mut OptMatch[T, mut Opt[T]]{
//    .some(x) -> this,
//    .empty -> f#
//    }),
////   TODO: this is the method that breaks the adapter ok check for imm Opt[read T] < imm Opt[imm T]
//  read .or(f: mut OptOrElse[read Opt[T]]): read Opt[T] -> this.match[read Opt[T]](mut OptMatch[read T, read Opt[T]]{
//    .some(x) -> this,
//    .empty -> f#
//    }),
//  imm .or(f: mut OptOrElse[Opt[T]]): Opt[T] -> this.match[Opt[T]](mut OptMatch[T, Opt[T]]{
//      .some(x) -> this,
//      .empty -> f#
//      }),

  read .isEmpty: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> True, .some(_) -> False }),
  read .isSome: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> False, .some(_) -> True }),

  mut  .flow: mut Flow[T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  imm  .flow: mut Flow[imm T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  read .flow: mut Flow[read T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  }

OptMatch[T,R]:{ mut .some(x: T): R, mut .empty: R }
OptOrElse[R]:{ mut #: R }
OptMap[T,R]:OptMatch[T, mut Opt[R]]{
  mut #(t: T): R,
  .some(x) -> Opt#(this#x),
  .empty -> {}
  }

// TODO: proof of concept for extension methods
OptOrElseExt[T]:Extension[mut Opt[T], T]{
  mut .alt: T,
  #(opt) -> opt.match{ .some(x) -> x, .empty -> this.alt }
  }
