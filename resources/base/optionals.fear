package base

Opt:{ #[T](x: mdf T): mut Opt[mdf T] -> {
  .match(m) -> m.some(x),
  .matchHyg(m) -> m.some(x),
  }}
Opt[T]:NoMutHyg[mdf T]{
  read .match[R](m: mut OptMatch[recMdf T, mdf R]): mdf R -> m.none,
  read .matchHyg[R](m: lent OptMatchHyg[recMdf T, mdf R]): mdf R -> m.none,
  read !: recMdf T -> this.match(_OptUnwrap[recMdf T]),
  read .map[R](f: mut OptMap[recMdf T, mdf R]): mut Opt[mdf R] -> this.match(f),
  read .flatMap[R](f: mut OptFlatMap[recMdf T, mdf R]): mut Opt[mdf R] -> this.match(f),
  read .do(f: mut OptMatch[recMdf T, Void]): recMdf Opt[recMdf T] ->
    Yeet.with[Void, recMdf Opt[recMdf T]](this.match(f), this),
  read |(alt: recMdf T): recMdf T -> this || (OptOr#alt),
  read ||(alt: mut OptOr[recMdf T]): recMdf T -> this.match(alt),
  read .isNone: Bool -> this.match{ .none -> True, .some(_) -> False },
  read .isSome: Bool -> this.match{ .none -> False, .some(_) -> True },
  }
OptMatch[T,R]:{ mut .some(x: mdf T): mdf R, mut .none: mdf R }
OptMatchHyg[T,R]:{ lent .some(x: mdf T): mdf R, lent .none: mdf R }
OptMap[T,R]:OptMatch[mdf T, mut Opt[mdf R]]{
  mut #(x: mdf T): mdf R,
  .some(x) -> Opt#(this#x),
  .none -> {},
  }
OptFlatMap[T,R]:OptMatch[mdf T, mut Opt[mdf R]]{
  mut #(x: mdf T): mut Opt[mdf R],
  .some(x) -> this#x,
  .none -> {},
  }
OptDo[T]:OptMap[mdf T, mdf T]{ x -> x }

OptOr:{ #[T](alt: mdf T): lent OptOr[mdf T] -> { alt } }
OptOr[T]:OptMatch[mdf T, mdf T]{ .some(x) -> x }

_OptUnwrap[T]:OptMatch[mdf T, mdf T]{ .some(x) -> x, .none -> Abort! }
