package base

Iter[E]:{
  lent .next: lent Opt[mdf E],
  lent .find(p: lent IterPredicate[mdf E]): lent Opt[mdf E] -> this.next.matchHyg{
    .some(x) -> p#x.ifHyg{ .then -> Opt#x, .else -> this.find(p) },
    .none -> {}
    },
//  mut .find(p: mut IterPredicate[mdf E]): mut Opt[mdf E] -> Do#
//    .var[lent Opt[mdf E]] res = { this.next }
//    // TODO: inference breaks:
//    // .if{ mut #: Bool -> this.next.map{ e -> p#e } | False }.return{ res }
//    .if{ res.isSome }.return{{}}
//    .if{ mut #: Bool -> this.next.map{ e -> p#e } || {False} }.return{ res }
//    .return{ this.find(p) },

  lent .map[R](f: lent IterMapper[mdf E, mdf R]): lent Iter[mdf R] -> {
    .next -> this.next.matchHyg{
      .some(x) -> Opt#(f#x),
      .none -> {}
      }},
  lent .flatMap[R](f: lent IterMapper[mdf E, lent Iter[mdf R]]): lent Iter[mdf R] -> Let.hyg{
    .var -> this.map(f),
    .in(mapIter) -> Let.hyg{
      .var -> Ref#(mapIter.next),
      .in(optCurIter) -> lent Iter[mdf R]{ 'self
        .next -> optCurIter*.matchHyg({
          .some(curIter) -> curIter.next,
          .none -> Yeet.with(optCurIter := mapIter.next, optCurIter*.matchHyg{
            .some(nextIter) -> self.next,
            .none -> {}
            })
          })
        }
      }
    },
    lent ._flatMap[R](curIter: lent Iter[mdf R]): lent Opt[mdf R] -> {},
  lent .filter(p: lent IterPredicate[mdf E]): lent Iter[mdf E] -> { .next -> this.find(p) },

  lent .fold[R](initial: mdf R, f: lent IterFolderHyg[mdf E, mdf R]): mdf R -> this.next.matchHyg{
    .some(e) -> this.fold(f#(initial, e), f),
    .none -> initial
    },
  lent .foldImm[R](initial: R, f: lent IterFolderHyg[mdf E, R]): R -> this.next.matchHyg{
    .some(e) -> this.foldImm(f#(initial, e), f),
    .none -> initial
    },
  mut .foldMut[R](initial: mut R, f: mut IterFolder[mdf E, mut R]): mut R -> this.next.match{
    .some(e) -> this.foldMut(f#(initial, e), f),
    .none -> initial
    },

  lent .count: UInt -> this.fold[UInt](0u, IterFolderHyg[mdf E, UInt]{ acc, _ -> acc + 1u }),
  lent .for(f: lent IterForEacher[mdf E]): Void -> this.foldImm(Void, { _, e -> f#e }),
  lent .toList: mut List[mdf E] ->
    this.fold(iso List#[mdf E], { acc, e -> Yeet.with(acc.add(e), acc) }),
  lent .toLListMut: mut LListMut[mdf E] ->
    this.fold(iso LListMut[mdf E], { acc, e -> acc + e }),
  lent .str(toStr: lent IterMapper[mdf E, Str], joining: Str): Str -> (this.map(toStr))
    .fold[Str]("", IterFolderHyg[Str, Str]{ acc, e -> acc.len == 0u ? { .then -> acc + e, .else -> acc + joining + e } })
  }

IterForEacher[E]:{ lent #(e: mdf E): Void }
IterFolder[E,R]:{ mut #(acc: mdf R, e: mdf E): mdf R }
IterFolderHyg[E,R]:{ lent #(acc: mdf R, e: mdf E): mdf R }
IterScanner[E,R,S]:{ lent #(state: mut Ref[mdf S], e: mdf E): mdf S }
IterMapper[E,R]:{ lent #(e: mdf E): mdf R }
IterPredicate[E]:{ lent #(e: mdf E): Bool }
