package base

Iter[E]:{
  mut .next: mut Opt[mdf E],
//  mut .find(p: mut IterPredicate[mdf E]): mut Opt[mdf E] -> this.next.match{
//    .none -> {},
//    .some(e) -> p#e?{ .then -> Opt#e, .else -> this.find(p) },
//    },

  mut .map[R](f: mut IterMapper[mdf E, mdf R]): mut Iter[mdf R] -> { .next -> this.next.map{ a -> f#a } },
  }

IterForEacher[E]:{ mut #(e: mdf E): Void }
IterFolder[E,R]:{ mut #(acc: mdf R, e: mdf E): mdf R }
IterScanner[E,R,S]:{ mut #(state: mut Ref[mdf S], e: mdf E): mdf S }
IterMapper[E,R]:{ mut #(e: mdf E): mdf R }
IterPredicate[E]:{ mut #(e: mdf E): Bool }
