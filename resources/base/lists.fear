package base

// Cons#(1, Cons#(2, Cons#(4, {})))
LList:{
  #[E](h: E): LList[E] -> { .match(m) -> m.elem(h, {}) },
  .cons[E](h: E, t: LList[E]): LList[E] -> { .match(m) -> m.elem(h, t) },
  }
LList[E]:Sealed{
  .match[R](m: mut LListMatch[E, mdf R]): mdf R -> m.empty,
  .isEmpty: Bool -> this.match{ .empty -> True, .elem(_,_) -> False },
  .len: UInt -> this.match{ .empty -> 0u, .elem(_,t) -> t.len + 1u, },
  ++(l1: LList[E]): LList[E] -> this.match{
    .empty -> l1,
    .elem(h, t) -> LList.cons(h, t ++ l1)
    },
  +(e: E): LList[E] -> this ++ (LList#e),
  .get(i: UInt): iso Opt[E] -> this.match{
    .empty -> {},
    .elem(h, t) -> (i == 0u) ? { .then -> Opt#h, .else -> t.get(i - 1u) }
    },
  .head: iso Opt[E] -> this.match{
    .empty -> {},
    .elem(h,_) -> Opt#h,
    },
  .tail: LList[E] -> this.match{
    .empty -> {},
    .elem(_,t) -> t,
    },
  }
LListMatch[E,R]:{ mut .elem(head: E, tail: LList[E]): mdf R, mut .empty: mdf R }

LListMut:{
  #[E](head: mdf E): mut LListMut[mdf E] -> this.cons(head, {}),
  .cons[E](head: mdf E, tail: mut LListMut[mdf E]): mut LListMut[mdf E] -> {
    .match(m) -> m.elem(head, tail),
    .head -> Opt#[recMdf E](head),
    .headRaw -> Opt#[mdf E](head),
    .tail -> tail,
    },
  }
LListMut[E]:Sealed,NoMutHyg[mdf E]{
  read .match[R](m: mut LListMutMatch[recMdf E, mdf E, mdf R]): mdf R -> m.empty,
  read .head: mut Opt[recMdf E] -> {},
  read .tail: recMdf LListMut[mdf E] -> {},
  read .isEmpty: Bool -> this.match{ .empty -> True, .elem(_,_) -> False },
  read .len: UInt -> this.match{ .empty -> 0u, .elem(_,t) -> t.len + 1u, },
  read .get(i: UInt): mut Opt[recMdf E] -> this.match(_LListMutGet[recMdf E, mdf E]{ i }),

  mut .headRaw: mut Opt[mdf E] -> {},
  mut ++(l1: mut LListMut[mdf E]): mut LListMut[mdf E] -> this.headRaw.map{ h -> LListMut.cons(h, this.tail ++ l1) } | l1,
  mut +(e: mdf E): mut LListMut[mdf E] -> this ++ (LListMut#e),
  }
LListMutMatch[E,TE,R]:{
  mut .elem(head: mdf E, tail: read LListMut[mdf TE]): mdf R,
  mut .empty: mdf R,
  }
//  read .get(i: UInt): mut Opt[recMdf E] -> this.match{
//    .empty -> {},
//    .elem(h, t) -> (i == 0u).ThenElseHyg{ .then -> Opt#h, .else -> t.get(i - 1u) }
//    },
_LListMutGet[E,TE]:LListMutMatch[mdf E, mdf TE, mut Opt[mdf E]]{
  read .i: UInt,
  .empty -> {},
//  .elem(h, t) -> (i == 0u) ? { .then -> Opt#h, .else -> t.get(i - 1u) },
  mut .elem(h: mdf E, t: read LListMut[mdf TE]): mut Opt[mdf E] -> (this.i == 0u)?{ .then -> Opt#h, .else -> {} },
  }

////List[E]:Sealed,NoMutHyg[mdf E]{
////  read .size: UInt,
////  read .isEmpty: Bool,
////  read .get(i: UInt): iso Opt[recMdf E],
////  mut +(e: mdf E): Void,
////  mut ++(l1: recMdf List[mdf E]): Void,
////  }
