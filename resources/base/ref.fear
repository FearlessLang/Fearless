package base

Ref:{
  #[X](x: mdf X): mut Ref[mdf X] -> Magic!,
  readOnly #[X](x: X): mut RefImm[X] -> Ref.ofImm x,
  .ofImm[X](x: X): mut RefImm[X] -> Let#{
    .var -> Ref#(_BoxImm[X]{x}),
      .in(ref) -> {
         mut  .get: X -> ref.get.get,
         read .get: X -> ref.get.get,
         .swap(newX) -> ref.swap(_BoxImm[X]{newX}).get,
         }
      }
  }
Ref[X:imm,mut,read]:Sealed{
  mut  .get: mdf X,
  read .get: read X,
  mut  *: mdf X -> this.get[],
  read *: read X -> this.get[],

  mut .swap(x: mdf X): mdf X,
  mut :=(x: mdf X): Void -> Do#(this.swap(x)),
  mut .set(x: mdf X): Void -> this := x,
  mut <-(f: mut UpdateRef[mdf X]): mdf X -> this.swap(f#(this*[])),
  mut .update(f: mut UpdateRef[mdf X]): mdf X -> this <- f,
  mut  .toImm: mut Opt[mut RefImm[X]] -> {},
  read .toImm: mut Opt[read RefImm[X]] -> {},
  }
UpdateRef[X]:{ mut #(x: mdf X): mdf X }
RefImm[X:imm]:Ref[X]{
  read .get: X,
  read *: X -> this.get[],
  .toImm -> Opt#this,
  }
_BoxImm[X]:{ read .get: X }

Count[N:imm]:RefImm[N]{
  mut ++: N,
  mut --: N,
  mut +=(n: N): N,
  mut -=(n: N): N,
  mut *=(n: N): N,
  }
Count:{
  #(n: Int): mut Count[Int] -> this.int(n),
  .int(n: Int): mut Count[Int] -> Let#({
    .var -> Ref.ofImm n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1 },
      -- -> c <- { c' -> c' - 1 },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    }),
  .uint(n: UInt): mut Count[UInt] -> Let#({
    .var -> Ref.ofImm n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1u },
      -- -> c <- { c' -> c' - 1u },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    })
  }
