package base.test

Main: AppMain{
  #(sys) -> Block#
    .do {Block#(this.testMain(FTestRunner#sys))}
    .return {Void},
  .testMain(runner: mut TestRunner): read List[read TestResults]
  }

// TODO: When we have maps support nested test suites
FTestRunner: F[mut System, mut TestRunner]{sys -> Block#
  .var[mut List[mut Test]] tests = {List#}
  .var[mut List[mut TestSuite]] suites = {List#}
  .return {{'self
    .suite(title, registerTests) -> Block#
      .do {suites.add({.title -> title, .runner -> registerTests#(FTestRunner#sys)})}
      .return {self},

    .test(title, impl) -> Block#
      .do {tests.add({.title -> title, .impl -> impl})}
      .return {self},

    .run -> Block#
      .var[mut List[read TestResults]] results = {List#[read TestResults](FTestResults#("<unnamed>", self.runDirectTests[]))}
      .do {results.addAll(self.runSuiteTests[])}
      .return {results},
    mut .runDirectTests: mut List[TestResult] -> tests.iter
      .map{test -> Block#
        .do {test.impl#sys}
        .return {FTestResult#(test.title, FTestResultKind.passed)}
        }
      .list,
    mut .runSuiteTests: mut List[read TestResults] -> suites.iter
      .map{suite -> FTestResults#(suite.title, suite.runner.run.iter.flatMap{subSuites->subSuites.results.iter}.list)}
      .list,
    }}
  }
TestRunner: {
  mut .suite(title: Str, registerTests: F[mut TestRunner, mut TestRunner]): mut TestRunner,
  mut .test(title: Str, impl: AppMain): mut TestRunner,
  mut .run: read List[read TestResults],
  }

TestSuite: {read .title: Str, mut .runner: mut TestRunner}
Test: {read .title: Str, mut .impl: AppMain}
FTestResults: F[Str, read List[TestResult], read TestResults]{suiteTitle, results -> mut TestResults: {
  read .suiteTitle: Str -> suiteTitle,
  read .results: read List[TestResult] -> results,
  }}
FTestResult: F[Str, TestResultKind, TestResult]{title, kind -> TestResult: {.title: Str -> title, .kind: TestResultKind -> kind}}

TestResultKind: Sealed{.match[R](m: mut TestResultKindMatcher[R]): R}
FTestResultKind: {
  .passed: TestResultKind -> {.match(m) -> m.passed},
  .skipped: TestResultKind -> {.match(m) -> m.skipped},
  .failed(details: Str): TestResultKind -> {.match(m) -> m.failed(details)},
  .errored(details: Str): TestResultKind -> {.match(m) -> m.errored(details)},
  }
TestResultKindMatcher[R]: {
  mut .passed: R,
  mut .skipped: R,
  mut .failed(details: Str): R,
  mut .errored(details: Str): R,
  }

ResultReporter: {
  mut #(results: read List[read TestResults]): Void,
  }
