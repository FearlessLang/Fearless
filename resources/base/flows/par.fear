package base.flows

_PipelineParallelSink: _Sink{
  #[T](s: mut _Sink[T]): mut _PipelineParallelSink[T] -> Magic!,
  }
_PipelineParallelSink[T]: _Sink[T]

_PipelineParallelFlow: {
  .fromOp[E](source: mut FlowOp[E], size: Opt[UInt]): mut Flow[E] -> {'self
    // non-terminals
    .filter(p) -> this.fromOp(_Filter#(_PipelineParallelSink, source, p), {}),
    .map(f) -> this.fromOp(_Map#(_PipelineParallelSink, source, f), size),
    .flatMap(f) -> this.fromOp(_FlatMap#(_PipelineParallelSink, source, f), {}),
    mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R] ->
      this.fromOp(_Actor#[S,E,R](_PipelineParallelSink, source, state, f, onComplete), {}),
    mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R] ->
      this.fromOp(_Actor.anyRet[S,E,R](_PipelineParallelSink, source, state, f, onComplete), {}),
    .limit(n) -> this.fromOp(_Limit#(_PipelineParallelSink, source, n), size),

    // terminals
    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .var[mut Ref[mut Opt[R]]] res = {Ref#mut Opt[R]}
      .do {source.forRemaining(_PipelineParallelSink#[E]{'runner
        .stop -> source.stop,
        #(e) -> f#e.match{.some(e') -> Block#(res := (Opt#e'), runner.stop), .empty -> {}},
        })}
      .do {source.stop}
      .return {res.get},

    .find(p) -> self.findMap{e -> p#e ? {.then -> Opt#e, .else -> {}}},
    .any(p) -> self
      .findMap{e -> p#e ? {.then -> Opt#True, .else -> {}}}
      .isSome,
    .all(p) -> self
      .findMap{e -> p#e ? {.then -> {}, .else -> Opt#False}}
      .isEmpty,

    mut .fold[S](acc: S, f: read F[S,E,S]): S -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .var[mut Ref[S]] acc' = {Ref#acc}
      .do {source.forRemaining(_PipelineParallelSink#[E]{
        .stop -> {},
//        .stop -> source.stop,
        #(e) -> acc' := (f#(acc'.get, e)),
        })}
//      .do {source.stop}
      .return {acc'.get},
    // Pipeline parallel flows do not split so no combine is needed
    .fold(acc, f, combine) -> self.fold(acc, f),

    .size -> size.match[UInt]{
      .some(n) -> n,
      .empty -> self.fold[UInt](0u, {acc, _ -> acc + 1u}),
      },
    },

  #[E](e: E): mut Flow[E] -> Block#
    .var[mut Ref[mut Opt[E]]] seq = { Ref#(Opt#e) }
    .var[mut FlowOp[E]] source = {{ 'self
      .isRunning -> seq.get.isSome,
      .stop -> seq := {},
      .step(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, self.stop),
        },
      .forRemaining(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> Block#(downstream#x, downstream.stop, self.stop),
        .empty -> Block#(downstream.stop, self.stop),
        },
      }}
    .return {this.fromOp(source, Opt#[UInt]1u)},
//    .return {this.fromOp(source, Opt#1u)},
  }
