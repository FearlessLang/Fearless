package base.flows

// I could have .step with a read sink (so we know that sink operation can be parallelised) _and_ a .step with a mut sink
// which must be sequential. However, this adds implementation burden for people making flowable data structures and introduces
// new sources of runtime exceptions (i.e. accidentally calling the non .seq and it throwing because it would have to be
// unimplemented). Because _Sink/2 is a private trait, we can just manually make sure that a _Sink that would be unsafe
// to parallelise never runs in parallel. This should be easy because basically all parallel implementations of _Sink
// will be Magic!.

FlowOp[E]: {
  mut .step(sink: mut _Sink[E]): Void,
  mut .stop: Void,
  mut .isRunning: Bool,
  mut .forRemaining(downstream: mut _Sink[E]): Void -> Block#
    .do{this.step(downstream)}
    .if {this.isRunning.not} .return {{}}
    .return {this.forRemaining(downstream)},
  mut .isFinite: Bool -> True,
  mut .split: mut Opt[mut FlowOp[E]] -> {},
  }


_Sink: {
  #[T](s: mut _Sink[T]): mut _Sink[T] -> s,
  }
_Sink[T]: {
  mut #(x: T): Void,
  mut .stop: Void,
  }

// TODO: REUSE SINK OBJECTS! THE IDENTITY IS IMPORTANT FOR WHEN THEY ARE RAN IN PARALLEL!!!!!!!

_Filter: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], predicate: read F[E, Bool]): mut FlowOp[E] -> Block#
//    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opt#(sinkFactory#[E]{
//            .stop -> Block#(downstream.stop, isRunning := False),
            .stop -> downstream.stop,
            #(e) -> predicate#e ? {.then -> downstream#e, .else -> {}},
            })),
          upstream.step(sink.get!)
          )
        },
//    .stop -> Block#(isRunning := False, upstream.stop),
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
      }}
  }
_Map: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, R]): mut FlowOp[R] -> Block#
//    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return  {{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opt#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> downstream#(f#e),
            })),
          upstream.step(sink.get!)
          )
        },
//    .stop -> Block#(isRunning := False, upstream.stop),
//    .isRunning -> (isRunning*) && (upstream.isRunning),
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
    }}
  }
_FlatMap: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, mut Flow[R]]): mut FlowOp[R] -> Block#
    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opt#(sinkFactory#[E]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> f#e.list.iter.filter{_ -> op.isRunning}.for{e' -> downstream#e'},
            })),
          upstream.step(sink.get!)
          )
        },
      .stop -> upstream.stop,
//      .isRunning -> (isRunning*) && (upstream.isRunning),
      .isRunning -> isRunning*,
      }}
  }
