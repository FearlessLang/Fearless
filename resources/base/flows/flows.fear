package base.flows
alias base.Todo as Todo,

Flow: Sealed, _FlowExtensions, _FlowConverters{
  #[E]: mut Flow[E] -> mut EmptyFlow[E],
  #[E](e: E): mut Flow[E] -> _SeqFlow#[E](e),
  #[E](e1: E, e2: E): mut Flow[E] -> List#(e1, e2).flow,
  #[E](e1: E, e2: E, e3: E): mut Flow[E] -> List#(e1, e2, e3).flow,
  #[E](e1: E, e2: E, e3: E, e4: E): mut Flow[E] -> List#(e1, e2, e3, e4).flow,

  // These fromOp calls will always be sequential. Only flows made from specific standard library types
  // could have a parallel constructor.
  .fromOp[E](source: mut FlowOp[E]): mut Flow[E] -> _SeqFlow.fromOp(source, {}),
  .fromOp[E](source: mut FlowOp[E], size: UInt): mut Flow[E] -> _SeqFlow.fromOp(source, Opt#size),

  // This variant of fromOp asks the compiler to emit code that collects the source into an intermediary list to
  // avoid any concurrent modification issues if they would be possible during the execution of the flow.
  .fromMutSource[E](source: mut FlowOp[E]): mut Flow[E] -> _MutSourceCollection[E]#source,
  .fromMutSource[E](source: mut FlowOp[E], size: UInt): mut Flow[E] -> _MutSourceCollection[E]#source,
  }

Flow[E]: Sealed, Extensible[Flow[E]], _NonTerminalOps[E], _TerminalOps[E]{
  .self -> this,
  }

_NonTerminalOps[E]: {
  mut .filter(predicate: read F[E, Bool]): mut Flow[E],
  mut .map[R](f: read F[E, R]): mut Flow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R],
//  mut .chain(other: mut Flow[R]): mut Flow[R], // TODO: maybe

  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] -> this.actor[S,R](state, f, {_ -> {}}),
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R],
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] -> this.actorMut[S,R](state, f, {_ -> {}}),
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R],

  mut .limit(n: UInt): mut Flow[E],

  // TODO: this can keep size if it is known
  mut .scan[S:imm](acc: S, f: read F[S,E,S]): mut Flow[S] -> this.actor[mut Ref[S], S](Ref#[S]acc, {downstream, acc', e -> Block#(
    acc' := (f#(acc'.get, e)),
    downstream#(acc'.get),
    ActorRes.continue
    )}),
  }
_TerminalOps[E]: Sealed{
  mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R],
  mut .find(predicate: read F[E, Bool]): mut Opt[E],
  mut .any(predicate: read F[E, Bool]): Bool,
  mut .all(predicate: read F[E, Bool]): Bool,
  mut .fold[S](acc: S, f: read F[S,E,S]): S,
  mut .fold[S](acc: S, f: read F[S,E,S], combine: read F[S, S, S]): S,
  mut .size: UInt,

  mut .for(f: read F[E, Void]): Void -> this.fold(Void, {_, e -> f#e}),
  mut .list: mut List[E] -> this.fold(List#[E], {acc, e -> Block#(acc.add(e), acc)}),
  mut .max(compare: read F[E, E, Ordering]): mut Opt[E] -> this.fold[mut Opt[E]]({}, {max, b -> max.match{
    .empty -> Opt#b,
    .some(a) -> compare#(a, b).match{
      .less -> Opt#b,
      .equal -> max,
      .greater -> max,
      }
    }}, {a, b -> a.match{
      .empty -> b,
      .some(a') -> b.match{
        .empty -> a,
        .some(b') -> compare#(a', b').match{
          .less -> b,
          .equal -> a,
          .greater -> a,
          }
        }
      }})
  }

_FlowExtensions: {
  .str(separator: Str): mut Extension[mut Flow[Str], Str] -> {flow -> flow.fold[Str]("", {acc, str -> acc.size == 0u ? {
    .then -> acc + str,
    .else -> acc + separator + str,
    }})},

  .sum: mut Extension[mut Flow[Int], Int] -> {flow -> flow.fold[Int](0, {acc, e -> acc + e})},
  .uSum: mut Extension[mut Flow[UInt], UInt] -> {flow -> flow.fold[UInt](0u, {acc, e -> acc + e})},
  .fSum: mut Extension[mut Flow[Float], Float] -> {flow -> flow.fold[Float](0.0, {acc, e -> acc + e})},
  }

EmptyFlow[E]: Flow[E]{
  .filter(p) -> this,
  mut .map[R](f: read F[E, R]): mut Flow[R] -> mut EmptyFlow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R] -> mut EmptyFlow[R],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R] -> Block#(
    onComplete#state,
    mut EmptyFlow[imm R]),
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R] -> Block#(
    onComplete#state,
    mut EmptyFlow[R]),
  .limit(_) -> this,
  .findMap(_) -> {},
  .find(_) -> {},
  .any(p) -> False,
  .all(p) -> False,
  .fold(acc, _) -> acc,
  .fold(acc, _, _) -> acc,
  .size -> 0u,
  }

TerminalOnInfiniteError: { #: Info -> FInfo.str "Terminal operators cannot be called on infinite flows. Use an operation like .limit(5u) to bound the flow." }
