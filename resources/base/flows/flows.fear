package base.flows
alias base.Todo as Todo,

Flow: _FlowExtensions{
  #[E]: mut Flow[E] -> mut EmptyFlow[E],
  #[E](e: E): mut Flow[E] -> _SeqFlow#[E](e),
  #[E](e1: E, e2: E): mut Flow[E] -> List#(e1, e2).flow,
  #[E](e1: E, e2: E, e3: E): mut Flow[E] -> List#(e1, e2, e3).flow,
  #[E](e1: E, e2: E, e3: E, e4: E): mut Flow[E] -> List#(e1, e2, e3, e4).flow,

  .fromOp[E](source: mut FlowOp[E]): mut Flow[E] -> _SeqFlow.fromOp(source, {}),
  .fromOp[E](source: mut FlowOp[E], size: UInt): mut Flow[E] -> _SeqFlow.fromOp(source, Opt#size),
  }

Flow[E]: Sealed, Extensible[Flow[E]], _NonTerminalOps[E], _TerminalOps[E]{
  .self -> this,
  }

_NonTerminalOps[E]: {
  mut .filter(predicate: read F[E, Bool]): mut Flow[E],
  mut .map[R](f: read F[E, R]): mut Flow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R],
//  mut .chain(other: mut Flow[R]): mut Flow[R], // TODO: maybe
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[R] -> this.actor[S,R](state, f, {_ -> {}}),
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[R],
  mut .limit(n: UInt): mut Flow[E],

  // TODO: this can keep size if it is known
  mut .scan[S:imm](acc: S, f: read F[S,E,S]): mut Flow[S] -> this.actor[mut Ref[S], S](Ref#[S]acc, {downstream, acc', e -> Block#(
    acc' := (f#(acc'.get, e)),
    downstream#(acc'.get),
    ActorRes.continue
    )}),
  }
_TerminalOps[E]: Sealed{
  mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R],
  mut .find(predicate: read F[E, Bool]): mut Opt[E],
  mut .any(predicate: read F[E, Bool]): Bool,
  mut .all(predicate: read F[E, Bool]): Bool,
  mut .fold[S](acc: S, f: read F[S,E,S]): S,
  mut .size: UInt,

  mut .for(f: read F[E, Void]): Void -> this.fold(Void, {_, e -> f#e}),
  mut .list: mut List[E] -> this.fold(List#[E], {acc, e -> Block#(acc.add(e), acc)}),
  mut .max(compare: read F[E, E, Ordering]): mut Opt[E] -> this.fold[mut Opt[E]]({}, {max, b -> max.match{
    .empty -> Opt#b,
    .some(a) -> compare#(a, b).match{
      .less -> Opt#b,
      .equal -> max,
      .greater -> max,
      }
    }}),
  }

_FlowExtensions: {
  .str(separator: Str): mut Extension[mut Flow[Str], Str] -> {flow -> flow.fold[Str]("", {acc, str -> acc.size == 0u ? {
    .then -> acc + str,
    .else -> acc + separator + str,
    }})},

  .sum: mut Extension[mut Flow[Int], Int] -> {flow -> flow.fold[Int](0, {acc, e -> acc + e})},
  .uSum: mut Extension[mut Flow[UInt], UInt] -> {flow -> flow.fold[UInt](0u, {acc, e -> acc + e})},
  .fSum: mut Extension[mut Flow[Float], Float] -> {flow -> flow.fold[Float](0.0, {acc, e -> acc + e})},
  }

EmptyFlow[E]: Flow[E]{
  .filter(p) -> this,
  mut .map[R](f: read F[E, R]): mut Flow[R] -> mut EmptyFlow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R] -> mut EmptyFlow[R],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[R] -> Block#(
    onComplete#state,
    mut EmptyFlow[R]),
  .limit(_) -> this,
  .findMap(_) -> {},
  .find(_) -> {},
  .any(p) -> False,
  .all(p) -> False,
  .fold(acc, _) -> acc,
  .size -> 0u,
  }

TerminalOnInfiniteError: { #: Info -> FInfo.str "Terminal operators cannot be called on infinite flows. Use an operation like .limit(5u) to bound the flow." }
