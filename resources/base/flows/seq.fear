package base.flows

_SeqFlow: {
  .fromOp[E](source: mut FlowOp[E], size: Opt[UInt]): mut Flow[E] -> {'self
    // non-terminals
    .filter(p) -> this.fromOp(_Filter#[E](source, p), {}),
    mut .map[R](f: read F[E,R]): mut Flow[R] -> this.fromOp(_Map#[E,R](source, f), size),

    // terminals
    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> source.forRemaining[mut Opt[R]]{e -> Let#{
      .var -> f#e,
      .in(res) -> res.match{.some(_) -> ControlFlow.return res, .empty -> ControlFlow.continue},
      }}
      .match{.continue -> {}, .break -> {}, .return(x) -> x},
    .find(p) -> self.findMap{e -> p#e ? {.then -> Opt#e, .else -> {}}},
    .any(p) -> self
      .findMap{e -> p#e ? {.then -> Opt#True, .else -> {}}}
      .isSome,
    .all(p) -> self
      .findMap{e -> p#e ? {.then -> {}, .else -> Opt#False}}
      .isEmpty,

//    .fold(acc, f) -> source.step{e -> ControlFlow.continue(e)}.match{
//      .continue(e) -> self.fold(f#(acc, e), f),
//      .continue -> self.fold(acc, f),
//      .break -> acc,
//      .return(e) -> f#(acc, e),
//      },
    mut .fold[S](acc: S, f: read F[S,E,S]): S -> Block#
      .var[mut Ref[S]] acc' = {Ref#acc}
      .return {source.forRemainingSeq{
        mut #(e: E): mut ControlFlow[S] -> Block#(acc' := (f#(acc'.get, e)), ControlFlow.continue[S]),
        read #(e: E): mut ControlFlow[S] -> Error.str "No mutable access to the flow environment",
        }.match{
          .continue -> acc'.get,
          .break -> acc'.get,
          .return(_) -> acc'.get,
          }},
//      .return{self.forRemainingSeq[S] mut _Sink[E, S]{
//        mut #(e: E): mut ControlFlow[S] -> Block#(acc' := (f#(acc'.get, e)), ControlFlow.continue[S]),
//        read #(e: E): mut ControlFlow[S] -> Error.str "unreachable",
//        }.match[S]{
//          .continue -> acc'.get,
//          .break -> acc'.get,
//          .return(_) -> acc'.get,
//          }},

    .size -> size.match[UInt]{
      .some(n) -> n,
    // TODO: inference broken on .empty, see the test `branchingReturnTypes`
//      .empty -> self.fold[UInt](0u, {acc, _ -> acc + 1u}),
      .empty -> Block#
        .var[UInt] start = {0u}
        .return {self.fold(start, {acc, _ -> acc + 1u})}
      },
    },

  #[E](e: E): mut Flow[E] -> Block#
    .var[mut Ref[mut Opt[E]]] seq = { Ref#(Opt#e) }
    .var[mut FlowOp[E]] source = {{ 'self
      mut .step[R](sink: read _Sink[E,R]): mut ControlFlow[R] -> seq.swap(mut Opt[E]).match{
        .some(x) -> sink#x,
        .empty -> ControlFlow.break[R],
        },
      .forRemaining(sink) -> self.step(sink),
      }}
    .return {this.fromOp(source, Opt#1u)},
//    .return {this.fromOp(source, Opt#1u)},
  }
