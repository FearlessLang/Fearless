package base.flows

_Limit: {
  #[E](upstream: mut FlowOp[E], n: UInt): mut FlowOp[E] -> Block#
    .var[mut Count[UInt]] remaining = {Count.uint(n)}
    .return {{
      .isFinite -> True,
      mut .step[R](sink: mut _Sink[E,R]): mut ControlFlow[R] -> Block#
        .if {n == 0u} .return {ControlFlow.break[R]}
        .return {upstream.step{e -> Block#
          .if {remaining-- == 0u} .return {ControlFlow.break[R]}
          .return {sink#e}
          }},
      mut .forRemaining[R](sink: mut _Sink[E,R]): mut ControlFlow[R] -> Block#
        .if {n == 0u} .return {ControlFlow.break[R]}
        .return {upstream.forRemaining{e -> Block#
          .if {remaining-- == 0u} .return {ControlFlow.break[R]}
          .return {sink#e}
          }}
      }},
  }

//_Actor: {
//  #[E,R](upstream: mut FlowOp[E], state: iso S, f: read F[S, mut _Sink[E,R]])
//  }
