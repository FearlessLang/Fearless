package base

Block[R]:{
  read .return(a: mut ReturnStmt[mdf R]): mdf R -> a#,
  read .do(a: mut Do): read Block[mdf R] -> this._do(a#),
    read ._do(v: Void): read Block[mdf R] -> {},
  read .var[X](x: mut ReturnStmt[mdf X], cont: mut Continuation[mdf X, mdf R]): mdf R -> cont#(x#, this),
  read .if(a: mut Condition): read BlockIf[mdf R] -> a#.hygIf{
    .then -> read BlockIfTrue[mdf R]{ this },
    .else -> read BlockIfFalse[mdf R]{ this }
    },
  }

BlockIf[R]:{
  read ._outer: read Block[mdf R],
  read .return(a: mut ReturnStmt[mdf R]): read Block[mdf R],
  read .error(a: mut ReturnStmt[Void]): read Block[mdf R], // todo: proper errors
  read .do(a: mut Do): read Block[mdf R],
  }
BlockIfTrue[R]:BlockIf[mdf R]{
  .return(a) -> this._return(a#),
    read ._return(x: mdf R): recMdf DecidedBlock[mdf R] -> { x },
  .error(a) -> this.error(a),
  .do(a) -> this._do(a#),
    read ._do(v: Void): read Block[mdf R] -> this._outer,
  }
BlockIfFalse[R]:BlockIf[mdf R]{
  .return(a) -> this._outer,
  .error(a) -> this._outer,
  .do(a) -> this._outer,
  }
DecidedBlock[R]:Block[mdf R]{
  read ._res: recMdf R,
  .return(a) -> this._res,
  .do(a) -> this,
  .var(_,_) -> this._res,
  .if(a) -> BlockIfFalse[mdf R]{ this },
  }

ReturnStmt[R]:NoMutHyg[R]{ mut #: mdf R }
Do:{ mut #: Void }
Condition:{ mut #: Bool }
Continuation[X,R]:{ mut #(x: mdf X, self: read Block[mdf R]): mdf R }

//Do:{ mut #: Void }
//ReturnStmt[R]:{ mut #: mdf R }
//Condition:{ mut #: Bool }
//Continuation[X,R]:{ mut #(x: mdf X, self: mut Block[mdf R]): mdf R }
////LoopBody[T]:{ mut #: ControlFlow[mdf T] }
////ControlFlow:{
////  read .continue: mut ControlFlow[Void] -> {},
////  read .break: mut ControlFlow[Void] -> { m -> m.break },
////  read .return[T](rv: mdf T): mut ControlFlow[mdf T] -> { m -> m.return(rv) }
////  }
////ControlFlow[T]:Sealed{
////  read .match[R](m: mut ControlFlowMatch[mdf T, mdf R]): mdf R -> m.continue,
////  }
////ControlFlowMatch[T,R]:{
////  mut .continue: mdf R,
////  mut .break: mdf R,
////  mut .return(rv: mdf T): mdf R,
////  }
//
//Block[R]:{
//  mut .return(a: mut ReturnStmt[mdf R]): mdf R -> a#,
//  mut .if(a: mut Condition): mut BlockIf[mdf R] -> a# ? {
//    .then -> BlockIfTrue[mdf R]{ this },
//    .else -> BlockIfFalse[mdf R]{ this },
//    },
//  mut .var[X](x: mut ReturnStmt[mdf X], cont: mut Continuation[mdf X,mdf R]): mdf R -> cont#(x#, this),
//  mut .do(a: mut Do): mut Block[mdf R] -> this._do(a#),
//  mut ._do(a: Void): mut Block[mdf R] -> this,
////  mut .loop(a: mut LoopBody[mdf R]): mut Block[mdf R] -> a#.match{
////    .continue -> this.loop(a),
////    .break -> this,
////    .return(rv) -> DecidedBlock[mdf R]{ rv },
////    },
//  }
//BlockIf[R]:{
//  mut .outer: mut Block[mdf R],
//  mut .return(a:mut ReturnStmt[mdf R]): mut Block[mdf R],
////  mut .error(a:mut ReturnStmt[Info]): mut Block[mdf R],
//  mut .do(a:mut Do): mut Block[mdf R],
//  }
//BlockIfTrue[R]:BlockIf[mdf R]{
//  .return(a) -> this._return(a#),
//  mut ._return(x: mdf R): mut DecidedBlock[mdf R] -> { x },
////  .error(a) -> Error#(a#),
//  .do(a) -> this._do(a#),
//  mut ._do(v: Void): mut Block[mdf R] -> this.outer,
//  }
//BlockIfFalse[R]:BlockIf[mdf R]{
//  .return(a) -> this.outer,
////  .error(a) -> this.outer,
//  .do(a) -> this.outer,
//  }
//DecidedBlock[R]:Block[mdf R]{
//  mut .res: mdf R,
//  .return(a) -> this.res,
//  .var(_,_) -> this.res,
//  .if(a) -> BlockIfFalse[mdf R]{this},
//  .do(a) -> this,
////  .loop(a) -> this,
//  }
