package base
alias base.caps.System as System,

Main:{ #(s: mut System): Void }
Sealed:{}
Void:{}

Abort:{ ![R]: mdf R -> this! } // can be optimised to just terminate (goes stuck)
Magic:{ ![R]: mdf R -> this! } // magic'd out to tell us what we forgot to implement
Debug:Sealed{ #[T](x: T): T -> x } // TODO: magic
HasIdentity:{ mut .idEq(other: read HasIdentity): Bool -> this.idEq(other) } // TODO: magic

Let:{
  recMdf #[V,R](l: mut Let[mdf V, mdf R]): mdf R -> l.in(l.var),
  recMdf .hyg[V,R](l: recMdf LetHyg[mdf V, mdf R]): mdf R -> l.in(l.var),
  }
Let[V,R]:{ mut .var: mdf V, mut .in(v: mdf V): mdf R }
LetHyg[V,R]:{ recMdf .var: mdf V, recMdf .in(v: mdf V): mdf R }

//LetMut:{ #[V,R](l:mut LetMut[mdf V, mdf R]): mdf R -> l.in(l.var) }
//LetMut[V,R]:{ mut .var: mdf V, mut .in(v: mdf V): mdf R }

F[R]:{ #: mdf R }
F[A,R]:{ #(a: mdf A): mdf R }
F[A,B,R]:{ #(a: mdf A, b: mdf B): mdf R }
F[A,B,C,R]:{ #(a: mdf A, b: mdf B, c: mdf C): mdf R }

Yeet:{
  #[X:mut,lent,read,imm,iso](x: mdf X): Void -> this.with(x, Void),
  .with[X:mut,lent,read,imm,iso, R:mut,lent,read,imm,iso](_: mdf X, res: mdf R): mdf R -> res,
  }
