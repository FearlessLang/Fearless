package base.iter.par

Iter[E]:{
  .cur: Opt[imm E],
  .next: Iter[imm E],
  .find(p: IterPredicate[imm E]): Opt[imm E] -> this.cur.match[Opt[imm E]]{
    .some(x) -> p#x ? { .then -> Opt#x, .else -> this.next.find(p) },
    .empty -> {}
    },
  .allMatch(p: IterPredicate[imm E]): Bool -> this.find{x -> p#x .not}.match[Bool]{
    .some(_) -> False,
    .empty -> True
    },
  .anyMatch(p: IterPredicate[imm E]): Bool -> this.find(p).match[Bool]{
    .some(_) -> True,
    .empty -> False
    },

  .map[R](f: IterMapper[imm E, imm R]): Iter[imm R] -> {
    .cur -> this.cur.map[imm R]{ e -> f#e },
    .next -> this.next.map[imm R](f),
    },
  .flatMap[R](f: IterMapper[imm E, Iter[imm R]]): Iter[imm R] -> _FlatMap[imm R].outer(this.map(f)),
  .filter(p: IterPredicate[imm E]): Iter[imm E] -> this.cur.match[Iter[imm E]]{
    .some(x) -> p#x ? {
      .then -> { .cur -> this.cur, .next -> this.next.filter(p) },
      .else -> this.next.filter(p),
      },
    .empty -> _Empty[imm E]
    },

  .fold[R](acc: R, f: IterFolder[imm E, R]): R -> this.cur.match[R]{
    .some(e) -> this.next.fold(f#(acc, e), f),
    .empty -> acc
    },
  .for(f: mut IterForEacher[imm E]): Void -> this.cur.match[Void]{
    .some(e) -> Block#(f#e, this.next.for(f)),
    .empty -> {}
    },

  .count: UInt -> this.fold[UInt](0u, IterFolder[imm E, UInt]{ acc, _ -> acc + 1u }),
  .list: mut List[imm E] -> this.fold(List#[imm E], { acc, e -> Block#(acc.add(e), acc) }),
  .llist: mut LList[imm E] -> this.fold(mut LList[imm E], { acc, e -> acc +[] e }),
  .str(toStr: IterMapper[imm E, Str], joining: Str): Str -> this.map(toStr)
    .fold[Str]("", IterFolder[Str, Str]{ acc, e -> acc.size == 0u ? { .then -> acc + e,
                                                                       .else -> acc + joining + e }})
  }

Sum:{
  .int(ns: Iter[Int]): Int -> ns.fold[Int](0, IterFolder[Int, Int]{ acc, n -> acc + n }),
  .uint(ns: Iter[UInt]): UInt -> ns.fold[UInt](0u, IterFolder[UInt, UInt]{ acc, n -> acc + n }),
  .float(ns: Iter[Float]): Float -> ns.fold[Float](0.0, IterFolder[Float, Float]{ acc, n -> acc + n }),
  }

IterForEacher[E]:{ mut #(e: imm E): Void }
IterFolder[E,R]:{ #(acc: R, e: imm E): R }
//IterScanner[E, R, S]:{ #(state: Ref[S], e: E): S }
IterMapper[E,R]:{ #(e: imm E): imm R }
IterPredicate[E]:{ #(e: imm E): Bool }

_FlatMap[R]:Sealed{
  .outer(mapIter: Iter[Iter[R]]): Iter[R] -> mapIter.cur.match[Iter[R]]{
    .some(inner) -> this.inner(mapIter, inner),
    .empty -> _Empty[R]
    },
  .inner(mapIter: Iter[Iter[R]], curIter: Iter[R]): Iter[R] -> curIter.cur.match{
    .some(cur) -> { .cur ->  Opt#cur, .next -> this.inner(mapIter, curIter.next) },
    .empty -> this.outer(mapIter.next),
    }
}
_Empty[E]:Iter[imm E]{ .cur -> {}, .next -> this }
