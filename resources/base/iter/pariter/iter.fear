package base.iter.par

Iter[E]:{
  .cur: Opt[E],
  .next: Iter[E],
  .find(p: IterPredicate[E]): Opt[E] -> this.cur.match[Opt[E]]{
    .some(x) -> p#x ? { .then -> Opt#x, .else -> this.next.find(p) },
    .empty -> {}
    },
  .allMatch(p: IterPredicate[E]): Bool -> this.find{x -> p#x .not}.match[Bool]{
    .some(_) -> False,
    .empty -> True
    },
  .anyMatch(p: IterPredicate[E]): Bool -> this.find(p).match[Bool]{
    .some(_) -> True,
    .empty -> False
    },

  .map[R](f: IterMapper[E, R]): Iter[R] -> {
    .cur -> this.cur.map[R]{ e -> f#e },
    .next -> this.next.map[R](f),
    },
  .flatMap[R](f: IterMapper[E, Iter[R]]): Iter[R] -> _FlatMap[R].outer(this.map(f)),
  .filter(p: IterPredicate[E]): Iter[E] -> this.cur.match[Iter[E]]{
    .some(x) -> p#x ? {
      .then -> { .cur -> this.cur, .next -> this.next.filter(p) },
      .else -> this.next.filter(p),
      },
    .empty -> _Empty[E]
    },

  .fold[R](acc: mdf R, f: IterFolder[E, mdf R]): mdf R -> this.cur.match[mdf R]{
    .some(e) -> this.next.fold(f#(acc, e), f),
    .empty -> acc
    },
  .for(f: mut IterForEacher[E]): Void -> this.cur.match[Void]{
    .some(e) -> Block#(f#e, this.next.for(f)),
    .empty -> {}
    },

  .count: UInt -> this.fold[UInt](0u, IterFolder[E, UInt]{ acc, _ -> acc + 1u }),
  .list: mut List[E] -> this.fold(List#[E], { acc, e -> Block#(acc.add(e), acc) }),
  .llist: mut LList[E] -> this.fold(mut LList[E], { acc, e -> acc +[] e }),
  .str(toStr: IterMapper[E, Str], joining: Str): Str -> this.map(toStr)
    .fold[Str]("", IterFolder[Str, Str]{ acc, e -> acc.len == 0u ? { .then -> acc + e,
                                                                         .else -> acc + joining + e }})
  }

Sum:{
  .int(ns: Iter[Int]): Int -> ns.fold[Int](0, IterFolder[Int, Int]{ acc, n -> acc + n }),
  .uint(ns: Iter[UInt]): UInt -> ns.fold[UInt](0u, IterFolder[UInt, UInt]{ acc, n -> acc + n }),
  .float(ns: Iter[Float]): Float -> ns.fold[Float](0.0, IterFolder[Float, Float]{ acc, n -> acc + n }),
  }

IterForEacher[E]:{ mut #(e: E): Void }
IterFolder[E,R]:{ #(acc: mdf R, e: E): mdf R }
//IterScanner[E, R, S]:{ #(state: Ref[S], e: E): S }
IterMapper[E,R]:{ #(e: E): R }
IterPredicate[E]:{ #(e: E): Bool }

_FlatMap[R]:Sealed{
  .outer(mapIter: Iter[Iter[R]]): Iter[R] -> mapIter.cur.match[Iter[R]]{
    .some(inner) -> this.inner(mapIter, inner),
    .empty -> _Empty[R]
    },
  .inner(mapIter: Iter[Iter[R]], curIter: Iter[R]): Iter[R] -> curIter.cur.match{
    .some(cur) -> { .cur ->  Opt#cur, .next -> this.inner(mapIter, curIter.next) },
    .empty -> this.outer(mapIter.next),
    }
}
_Empty[E]:Iter[E]{ .cur -> {}, .next -> this }
