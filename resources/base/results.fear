package base

Res:{
  #[T](x: mdf T): mut Res[mdf T] -> { .match(m) -> m.a(x), },
  .ok[T,E](x: mdf T): mut Res[mdf T, mdf E] -> { .match(m) -> m.a(x), },
  .err[T,E](x: mdf E): mut Res[mdf T, mdf E] -> { .match(m) -> m.b(x), },
  }
Res[T]:Res[mdf T, Info]
Res[T,E]:Either[mdf T, mdf E]{
  mut  .resMatch[R](m: mut ResMatch[mdf T, mdf E, mdf R]): mdf R -> this.match(m),
  read .resMatch[R](m: mut ResMatch[read T, read E, mdf R]): mdf R -> this.match(m),
  imm  .resMatch[R](m: mut ResMatch[T, E, mdf R]): mdf R -> this.match(m),

  mut  !: mdf T -> this.resMatch[mdf T]{ .ok(x) -> x, .err(_) -> Error.str "Res was not ok" },
  read !: read T -> this.resMatch[read T]{ .ok(x) -> x, .err(_) -> Error.str "Res was not ok" },
  imm  !: T -> this.resMatch[T]{ .ok(x) -> x, .err(_) -> Error.str "Res was not ok" },

  mut  .map[R](f: mut ResMap[mdf T, mdf E, mdf R]): mut Res[mdf R, mdf E] -> this.match(f),
  read .map[R](f: mut ResMap[read T, read E, mdf R]): mut Res[mdf R, read E] -> this.match(f),
  imm  .map[R](f: mut ResMap[T, E, mdf R]): mut Res[mdf R, E] -> this.match(f),

  mut  .mapErr[R](f: mut ResMapErr[mdf T, mdf E, mdf R]): mut Res[mdf T, mdf R] -> this.match(f),
  read .mapErr[R](f: mut ResMapErr[read T, read E, mdf R]): mut Res[read T, mdf R] -> this.match(f),
  imm  .mapErr[R](f: mut ResMapErr[T, E, mdf R]): mut Res[T, mdf R] -> this.match(f),

  mut  .ok: mut Opt[mdf T] -> this.resMatch{ .ok(x) -> Opt#x, .err(_) -> {} },
  read .ok: mut Opt[read T] -> this.resMatch{ .ok(x) -> Opt#x, .err(_) -> {} },
  imm  .ok: iso Opt[T] -> this.resMatch[mut Opt[T]]{ .ok(x) -> Opt#x, .err(_) -> {} },

  mut  .err: mut Opt[mdf E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opt#e },
  read .err: mut Opt[read E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opt#e },
  imm  .err: iso Opt[E] -> this.resMatch[mut Opt[E]]{ .ok(_) -> {}, .err(e) -> Opt#e },

  read .isErr: Bool -> this.resMatch{ .err(_) -> True, .ok(_) -> False },
  read .isOk: Bool -> this.resMatch{ .err(_) -> False, .ok(_) -> True },
  }

ResMatch[T,E,R]:EitherMatch[mdf T, mdf E, mdf R]{
  .a(x) -> this.ok(x), .b(x) -> this.err(x),
  mut .ok(x: mdf T): mdf R,
  mut .err(x: mdf E): mdf R
  }
ResMap[T,E,R]:ResMatch[mdf T, mdf E, mut Res[mdf R, mdf E]]{
  mut #(x: mdf T): mdf R,
  .ok(x) -> Res.ok[mdf R, mdf E](this#x),
  .err(x) -> Res.err[mdf R, mdf E](x),
  }
ResMapErr[T,E,R]:ResMatch[mdf T, mdf E, mut Res[mdf T, mdf R]]{
  mut #(x: mdf E): mdf R,
  .ok(x) -> Res.ok[mdf T, mdf R](x),
  .err(x) -> Res.err[mdf T, mdf R](this#x),
  }
