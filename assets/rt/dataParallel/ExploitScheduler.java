package rt.dataParallel;

import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.atomic.AtomicInteger;

final class ExploitScheduler {
  private final AtomicInteger availability;
  private final ConcurrentLinkedDeque<Task> running = new ConcurrentLinkedDeque<>();
  private final ConcurrentLinkedDeque<Task> blocked = new ConcurrentLinkedDeque<>();
  public ExploitScheduler(int maxParallelism) {
    this.availability = new AtomicInteger(maxParallelism);
  }

  public synchronized void acquire(Task worker) {
    var cost = worker.cost();
    while (true) {
      var availability_ = availability.getAcquire();
      assert availability_ >= 0 : "Availability should always be positive (was "+availability_+")";
      if (availability_ >= cost) {
        int next = availability_ - cost;
        if (availability.weakCompareAndSetRelease(availability_, next)) { break; }
        continue;
      }
      // TODO: the whole blocking thing
      var oldTask = running.pollFirst();
      while (oldTask == null) {
        oldTask = running.pollFirst();
      }
      oldTask.suspend();
      blocked.offerLast(oldTask);
      availability.getAndAdd(oldTask.cost());
    }
    running.offerLast(worker);
    worker.spawn();
  }

  public synchronized void release(Task worker) {
    running.remove(worker);
    blocked.remove(worker);
    availability.getAndAdd(worker.cost());
    resumeMostRecentTask();
  }

  private synchronized void resumeMostRecentTask() {
    var task = blocked.pollLast();
    if (task == null) { return; }
    var cost = task.cost();
    while (true) {
      var availability_ = availability.getAcquire();
      assert availability_ >= 0 : "Availability should always be positive (was "+availability_+")";
      if (availability_ < cost) { return; }
      int next = availability_ - cost;
      if (availability.weakCompareAndSetRelease(availability_, next)) { break; }
    }
    running.offerLast(task);
    task.resume();
  }

  public interface Task {
    int cost();
    void spawn();
    void resume();
    void suspend();
  }
}
