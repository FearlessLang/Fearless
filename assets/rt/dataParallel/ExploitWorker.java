package rt.dataParallel;

import base.OptMatch_2;
import base.flows.FlowOp_1;
import base.flows._Sink_1;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

final class ExploitWorker implements Runnable {
  private static final int TASKS_PER_CORE = 5;
  private static final int N_CPUS = Runtime.getRuntime().availableProcessors();
  private static final int PARALLELISM_POTENTIAL = TASKS_PER_CORE * N_CPUS;
  //  private static final int PARALLELISM_POTENTIAL = 4;
  private static final Semaphore AVAILABLE_PARALLELISM = new Semaphore(PARALLELISM_POTENTIAL);
  private static final AtomicLong waitingTasks = new AtomicLong();

  @SuppressWarnings("preview")
  private static final ScopedValue<AtomicInteger> INFO = ScopedValue.newInstance();

//  12,586,269,025

  private static final int GUESSED_LATENT_PARALLELISM = 10;
  public static void forRemaining(FlowOp_1 source, _Sink_1 downstream, int size) {
    var splitData = new FlowOp_1[PARALLELISM_POTENTIAL];
    splitData[0] = source;
    int i = 1;
    for (; i < PARALLELISM_POTENTIAL; ++i) {
      var split = (FlowOp_1) splitData[i - 1].split$mut().match$mut(new OptMatch_2() {
        @Override public Object some$mut(Object split_) {
          return split_;
        }
        @Override public Object empty$mut() {
          return null;
        }
      });
      if (split == null) { break; }
      splitData[i] = split;
    }
    final var nTasks = i;
    // TODO: change parallelism strategy based on nTasks (i.e. if it's 2, do a classic fork-join and only run one in parallel)
    int realSize = size >= 0 ? size : nTasks;
    int perWorkerSize = realSize / nTasks;

    if (Thread.currentThread().isVirtual()) {
      releaseParentPermit();
    }

    var willParallelise = true;
    if (!AVAILABLE_PARALLELISM.tryAcquire(nTasks)) {
      if (waitingTasks.getPlain() < 10) { //TODO: for some reason if we ever run seq here instead of blocking we can end up having unbounded concurrency when availability > 1
        waitingTasks.getAndIncrement();
        AVAILABLE_PARALLELISM.acquireUninterruptibly(nTasks);
        waitingTasks.getAndDecrement();
      } else {
        willParallelise = false;
      }
    }
    final var parallelTasks = willParallelise ? nTasks: 0;
    var permits = new AtomicInteger(parallelTasks);

    var doneSignal = new CountDownLatch(nTasks);
    var workers = new ExploitWorker[nTasks];
    for (int j = 0; j < nTasks; ++j) {
      var subSource = splitData[j];
      var worker = new ExploitWorker(subSource, downstream, perWorkerSize, doneSignal, permits);
      if (willParallelise) {
        Thread.ofVirtual().start(worker);
      } else {
        worker.run();
      }
      workers[j] = worker;
    }
    try {
      doneSignal.await();
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    while (permits.get() > 0) {
      tryReleaseAll(permits);
    }
    for (var worker : workers) {
      if (worker == null) { break; }
      worker.downstream.flush();
    }
  }


  /**
   * If we're entering new data-parallelism within a DP worker already, we need to release our parents permits
   * to prevent deadlocks.
   */
  @SuppressWarnings("preview")
  private static void releaseParentPermit() {
    assert Thread.currentThread().isVirtual();
    var info = INFO.get();
    tryReleaseAll(info);
  }

  private static void tryReleaseAll(AtomicInteger permits) {
    int remaining;
    do {
      remaining = permits.get();
      assert remaining >= 0;
      if (remaining == 0) { return; }
    } while (!permits.compareAndSet(remaining, 0));
    AVAILABLE_PARALLELISM.release(remaining);
  }

  private final FlowOp_1 source;
  private final BufferSink downstream;
  private final CountDownLatch doneSignal;
  private final AtomicInteger info;

  private ExploitWorker(FlowOp_1 source, _Sink_1 downstream, int size, CountDownLatch doneSignal, AtomicInteger info) {
    this(
      source,
      downstream,
      doneSignal,
      info,
      // size isn't always going to be the correct answer here but in most cases it will be.
      size >= 0 ? new ArrayList<>(size) : new ArrayList<>()
    );
  }
  private ExploitWorker(FlowOp_1 source, _Sink_1 downstream, CountDownLatch doneSignal, AtomicInteger info, List<Object> buffer) {
    this.source = source;
    this.info = info;
    this.downstream = new BufferSink(downstream, buffer);
    this.doneSignal = doneSignal;
  }

  @SuppressWarnings("preview")
  @Override public void run() {
    ScopedValue
      .where(INFO, info)
      .run(()->source.forRemaining$mut(downstream));
    doneSignal.countDown();
  }
//
//  public void release() {
//    if (!HAS_RELEASED.isBound()) {
//      AVAILABLE_PARALLELSIM.release(1);
//    }
//  }
}
