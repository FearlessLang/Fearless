package rt.dataParallel;

import base.False_0;
import base.OptMatch_2;
import base.True_0;
import base.flows.FlowOp_1;
import base.flows._Sink_1;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.locks.LockSupport;

final class ExploitWorker implements ExploitScheduler.Task, Runnable {
  private static final int TASKS_PER_CORE = 5;
  private static final int N_CPUS = Runtime.getRuntime().availableProcessors();
  private static final int PARALLELISM_POTENTIAL = N_CPUS * TASKS_PER_CORE;
  private static final ExploitScheduler scheduler = new ExploitScheduler(PARALLELISM_POTENTIAL);

//  12,586,269,025

  private static final int GUESSED_LATENT_PARALLELISM = 10;
  public static void forRemaining(FlowOp_1 source, _Sink_1 downstream, int size) {
    // Try to split up the source N_CPU times
    // TODO: we probably want to just do this on some of the dataset to try it out first
    var splitData = new FlowOp_1[N_CPUS];
    int i = 1;
    splitData[0] = source;
    for (; i < N_CPUS; ++i) {
      var split = (FlowOp_1) splitData[i - 1].split$mut().match$mut(new OptMatch_2() {
        @Override public Object some$mut(Object split_) {
          return split_;
        }
        @Override public Object empty$mut() {
          return null;
        }
      });
      if (split == null) { break; }
      splitData[i] = split;
    }
    int realSize = size >= 0 ? size : i;
    int perWorkerSize = realSize / i;

    var doneSignal = new CountDownLatch(i);
    var workers = new ExploitWorker[i];
    for (int j = 0; j < i; ++j) {
      var subSource = splitData[j];
      assert subSource != null;
      var worker = new ExploitWorker(subSource, downstream, perWorkerSize, doneSignal);
      scheduler.acquire(worker);
      workers[j] = worker;
    }
    try {
      doneSignal.await();
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    for (var worker : workers) {
      if (worker == null) { break; }
      worker.flush();
    }
  }

  private final FlowOp_1 source;
  private final BufferSink downstream;
  private final int latentParallelism;
  private final CountDownLatch doneSignal;
  private volatile Thread joinHandle;
  private volatile boolean suspended = false;

  public ExploitWorker(FlowOp_1 source, _Sink_1 downstream, int size, CountDownLatch doneSignal) {
    this(
      source,
      downstream,
      size,
      doneSignal,
      // size isn't always going to be the correct answer here but in most cases it will be.
      size >= 0 ? new ArrayList<>(size) : new ArrayList<>()
    );
  }
  public ExploitWorker(FlowOp_1 source, _Sink_1 downstream, int size, CountDownLatch doneSignal, List<Object> buffer) {
    this.source = source;
    this.downstream = new BufferSink(downstream, buffer);
    this.latentParallelism = size >= 0 ? size : GUESSED_LATENT_PARALLELISM;
    this.doneSignal = doneSignal;
  }

  public void flush() {
    try {
      // there is a small chance that the thread is still in the process of terminating when this runs,
      // wait for it here.
      joinHandle.join();
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    downstream.flush();
//    scheduler.release(this);
  }

  @Override public int cost() {
    return 1;
  }

  @Override public void spawn() {
    joinHandle = Thread.ofVirtual().start(this);
//    System.out.println("spawning "+joinHandle);
  }

  @Override public void resume() {
//    System.out.println("Called resume on "+joinHandle);
    this.suspended = false;
    LockSupport.unpark(joinHandle);
  }

  @Override public void suspend() {
//    while (joinHandle == null) {
//      Thread.onSpinWait();
//    }
//    if (joinHandle.getState() == Thread.State.WAITING) { return; }
//    System.out.println("Called suspend on "+joinHandle);
    this.suspended = true;
//    try {
//      joinHandle.wait();
//    } catch (InterruptedException e) {
//      throw new RuntimeException(e);
//    }
  }

  @Override public void run() {
    while (true) {
      if (suspended) {
//        System.out.println("suspending "+this.joinHandle);
        LockSupport.park();
//        System.out.println("waking "+this.joinHandle);
      }
      if (source.isRunning$mut() == False_0.$self) {
        break;
      }
      source.step$mut(downstream);
    }
//    source.forRemaining$mut(downstream);
    scheduler.release(this);
    doneSignal.countDown();
  }

  @Override public String toString() {
    return "ExploitWorker: "+joinHandle;
  }
}
