package base
alias base.caps.System as System,

Main: { #(s: mut System): Void }
Sealed: {}
Void: Sealed{}

Abort: Sealed{ ![R:readOnly,lent,read,mut,imm,iso]: R -> this! } // can be optimised to just terminate (goes stuck)
Magic: Sealed{ ![R:readOnly,lent,read,mut,imm,iso]: R -> this! } // magic'd out to tell us what we forgot to implement
Debug: Sealed{ #[T](x: T): T -> x }
HasIdentity: { mut .idEq(other: readOnly HasIdentity): Bool -> Magic! } // TODO: magic

As[X:imm,mut,read,iso]: Sealed{ #(x: X): X -> x }

Let: {
  #[V,R](l: mut Let[V, R]): R -> l.in(l.var),
  }
Let[V,R]: { mut .var: V, mut .in(v: V): R }

F[R:read,mut,imm,iso]: { read #: R }
F[A:read,mut,imm,iso,R:read,mut,imm,iso]: { read #(a: A): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B, c: C): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, D:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B, c: C, d: D): R }

Consumer[A:read,mut,imm,iso]: { mut #(a: A): Void }
Consumer[A:read,mut,imm,iso, B:read,mut,imm,iso]: { mut #(a: A, b: B): Void }
Consumer[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso]: { mut #(a: A, b: B, c: C): Void }

ToImm[R]: { readOnly .toImm: imm R, }
Freezer[T,R]: { mut #(self: T): imm R }
Ice[T]: { readOnly .get: imm T }

Box[T]: {
  mut  .get: T,
  read .get: read T,
  imm  .get: imm T,
  }