package base.flows

_PipelineParallelSink: _Sink{
  #[T](s: mut _Sink[T]): mut _Sink[T] -> Magic!,
  }
_PipelineParallelSink[T]: _Sink[T]

_PipelineParallelFlow: _FlowFactory{
  .fromOp[E](source: mut FlowOp[E], size: Opt[Nat]): mut Flow[E] -> {'self
    .unwrapOp(_) -> source,
    // non-terminals
    .filter(p) -> this.fromOp(_Filter#(_PipelineParallelSink, source, p), {}),

    .map(f) -> this.fromOp(_Map#(_PipelineParallelSink, source, f), size),
    .map(ctx, recoverCtx, f) -> this.fromOp(_Map#(_PipelineParallelSink, source, ctx, recoverCtx, f), size),

    .flatMap(f) -> this.fromOp(_FlatMap#(_PipelineParallelSink, source, f), {}),
    mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] ->
      this.fromOp(_Actor#[S,E,R](_PipelineParallelSink, source, state, f), {}),
    mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] ->
      this.fromOp(_Actor.anyRet[S,E,R](_PipelineParallelSink, source, state, f), {}),
    .limit(n) -> this.fromOp(_Limit#(_PipelineParallelSink, source, n), _LimitSize#(n, size)),
    .with(other) -> this.fromOp(_With#(_PipelineParallelSink, source, other.unwrapOp(mut _UnwrapFlowToken)), {}),

    // terminals
    mut .first: mut Opt[E] -> Block#
      .let[mut Var[mut Opt[E]]] res = {Var#mut Opt[E]}
      .let stopped = {Var#[Bool]False}
      .do {source.forRemaining(_PipelineParallelSink#[E]{'runner
        .stop -> Block#
          .do {stopped := True}
          .return {source.stop},
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        #(e) -> res.get.isEmpty ? {
          .then -> Block#
            .do {res := (Opts#e)}
            .return {runner.stop},
          .else -> {},
          },
        })}
      .do {source.stop}
      .return {res.get},

    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> Block#
      .let[mut Var[mut Opt[R]]] res = {Var#mut Opt[R]}
      .let stopped = {Var#[Bool]False}
      .do {source.forRemaining(_PipelineParallelSink#[E]{'runner
        .stop -> Block#
          .do {stopped := True}
          .return {source.stop},
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        #(e) -> res.get.isEmpty ? {
          .then -> f#e.match{
            .some(e') -> Block#
              .do{res := (Opts#e')}
              .return {runner.stop},
            .empty -> {},
            },
          .else -> {},
          },
        })}
      .do {source.stop}
      .return {res.get},

    mut .fold[S](acc: S, f: read F[S,E,S]): S -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .let[mut Var[S]] acc' = {Var#acc}
      .let stopped = {Var#[Bool]False}
      .do {source.forRemaining(_PipelineParallelSink#[E]{
        #(e) -> acc' := (f#(acc'.get, e)),
        .stop -> stopped := True,
        .pushError(info) -> stopped* ? {
          .then -> {},
          .else -> Error!info,
          },
        })}
      .do {source.stop}
      .return {acc'.get},

    .size -> size.match{
      .some(n) -> n,
      .empty -> self.fold[Nat](0, {acc, _ -> acc + 1}),
      },
    },

  #[E](e: E): mut Flow[E] -> Error.msg "_PipelineParallelFlow# should not be reachable",
//  #[E](e: E): mut Flow[E] -> Block#
//    .let[mut Var[mut Opt[E]]] seq = { Var#(Opts#e) }
//    .let[mut FlowOp[E]] source = {RestrictFlowReuse#[E]{'self
//      .isRunning -> seq.get.isSome,
//      .stop -> seq := {},
//      .step(downstream) -> seq.swap(mut Opt[E]).match{
//        .some(x) -> downstream#x,
//        .empty -> Block#(downstream.stop, self.stop),
//        },
//      .forRemaining(downstream) -> seq.swap(mut Opt[E]).match{
//        .some(x) -> Block#(downstream#x, downstream.stop, self.stop),
//        .empty -> Block#(downstream.stop, self.stop),
//        },
//      }}
//    .return {this.fromOp(source, Opts#[Nat]1)},
  }
