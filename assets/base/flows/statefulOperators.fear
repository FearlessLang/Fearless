package base.flows

// This could be implemented as an actor, but I have it special cased because it forces a Flow to be finite and gives
// it a static size, which is more info than we could get if this was just an ActorImpl.
_Limit: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], n: UInt): mut FlowOp[E] -> Block#
    .let[mut Count[UInt]] remaining = {Count.uint(n)}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return {{ 'runner
      .stop -> Block#(remaining := 0u, upstream.stop),
      .isRunning -> remaining* > 0u && (upstream.isRunning),
//      .stop -> upstream.stop,
//      .isRunning -> upstream.isRunning,
      .isFinite -> True,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .if {n == 0u} .return {runner.stop}
          .do {sink := (Opt#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> remaining* == 0u || (remaining-- == 0u) ? {
              .then -> runner.stop,
              .else -> downstream#e
              }
            }))}
          .return {upstream.step(sink.get!)}
        },
//      mut .forRemaining[R](sink: mut _Sink[E]): Void -> Block#
//        .if {n == 0u} .return {ControlFlow.break[R]}
//        .return {upstream.forRemaining{e -> Block#
//          .if {remaining-- == 0u} .return {ControlFlow.break[R]}
//          .return {sink#e}
//          }}
      }},
  }

_Actor: {
  // Delegates to _InternalActor to unwrap the iso state so it can be captured as whatever the user wants.
  #[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut FlowOp[imm R] ->
    _InternalActor#[S,E,R](sinkFactory, upstream, state, f, onComplete),

  .anyRet[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut FlowOp[R] ->
    _InternalActor.anyRet[S,E,R](sinkFactory, upstream, state, f, onComplete),
  }
_InternalActor: {
  #[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut FlowOp[imm R] -> Block#
    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return {{'op
      .stop -> op.isRunning ? {
       .then -> Block#(isRunning := False, upstream.stop, onComplete#state),
       .else -> {}
       },
      .isRunning -> isRunning*,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .do {sink := (Opt#(sinkFactory#[E]{
            .stop -> Block#(downstream.stop, op.stop),
            #(e) -> isRunning.get ? {
              .then -> f#(downstream, state, e).match{
                .continue -> {},
                .stop -> Block#(downstream.stop, isRunning := False, onComplete#state),
                },
              .else -> op.stop,
              },
            }))}
          .return {upstream.step(sink.get!)}
        },
      }},

  .anyRet[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: mut S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut FlowOp[R] -> Block#
    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return {{'op
      .stop -> op.isRunning ? {
       .then -> Block#(isRunning := False, upstream.stop, onComplete#state),
       .else -> {}
       },
      .isRunning -> isRunning*,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .do {sink := (Opt#(sinkFactory#[E]{
            .stop -> Block#(downstream.stop, op.stop),
            #(e) -> f#(downstream, state, e).match{
              .continue -> {},
              .stop -> Block#(downstream.stop, isRunning := False, onComplete#state),
              },
            }))}
          .return {upstream.step(sink.get!)}
        },
      }},
  }

ActorImpl[S,E,R]: { read #(downstream: mut _Sink[imm R], state: S, e: E): ActorRes }
ActorImplMut[S,E,R]: { read #(downstream: mut _Sink[R], state: lent S, e: E): ActorRes }
// Alternatively, we could use an isopod and check if the isopod still has content before/after running
// the actor. Of course, the actor could send the isopod downstream, which would enable parallelism to be observed
// by virtue of it crashing. This could happen anyway in parallel so I think it'd be fine.
//ActorImplMut[S,E,R]: { read #(downstream: mut _Sink[R], state: mut IsoPod[S], e: E): ActorRes }

ActorRes: Sealed{
  .match[R](m: mut ActorResMatch[R]): R -> m.continue,
  .continue: ActorRes -> {.match(m) -> m.continue},
  .stop: ActorRes -> {.match(m) -> m.stop},
  }
ActorResMatch[R]: { mut .continue: R, mut .stop: R, }
