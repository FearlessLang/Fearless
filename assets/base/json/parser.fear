package base.json

// Strictly follows https://www.json.org/json-en.html
ParseJson: {#(input: Str): Json -> input.flow
  .actor[mut _LexerCtx,Token](_LexerCtxs#, {downstream, state, e -> Block#
    .let wasEscaped = {state.isEscaped}
    .do {state.isEscaped(False)}
    .do {state.write(e)}
    .if {(state.str == "\"") && (wasEscaped.not)}
      .return {Block#
        .if {state.isStrMode} .do {downstream#(Tokens.quoted(state.str))}
        .do {state.toggleStrMode}
        .do {state.clear}
        .return {ActorRes.continue}
        }
    // TODO: check for control characters if in string (should terminate string mode and tokenize as an unknownFragment
    .if {state.isStrMode} .return {{}}
    .if {state.str == "null"} .return {Block#(downstream#(Tokens.null), state.clear, ActorRes.continue)}
    .if {state.str == "["} .return {Block#(downstream#(Tokens.os), state.clear, ActorRes.continue)}
    .if {state.str == "]"} .return {Block#(downstream#(Tokens.cs), state.clear, ActorRes.continue)}
    .if {state.str == "{"} .return {Block#(downstream#(Tokens.oc), state.clear, ActorRes.continue)}
    .if {state.str == "}"} .return {Block#(downstream#(Tokens.cc), state.clear, ActorRes.continue)}
    .if {state.str == ","} .return {Block#(downstream#(Tokens.comma), state.clear, ActorRes.continue)}
    .return {{}}
    })
    .fold(Jsons.null, {acc, _ -> acc})
  }

_LexerCtxs: {#: mut _LexerCtx -> Block#
  .let buffer = {mut ""}
  .let mode = {Var#[_LexerMode]_LexeerModes.value}
  .return {mut _LexerCtx: Stringable{'state
    mut .write(e: Str): Void -> buffer.append(e),
    mut .clear: Void -> buffer.clear,
    .str -> buffer.str,

    read .isStrMode: Bool -> isStrMode.get,
    mut .toggleStrMode: Void -> isStrMode.set(isStrMode.get.not),

    read .isEscaped: Bool -> isEscaped.get,
    mut .isEscaped(value: Bool): Void -> isEscaped.set(value),
    }}
  }

TokenMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .null: R,
  mut .true: R,
  mut .false: R,
  mut .quoted(chars: Str): R,
  mut .numeric(chars: Str): R,

  mut .os: R,
  mut .cs: R,
  mut .oc: R,
  mut .cc: R,
  mut .quote: R,
  mut .comma: R,
  mut .colon: R,

  // The error case:
  mut .unknownFragment(bufferContents: Str): R,
  }
Tokens: {
  .null: Token -> {m -> m.null},
  .os: Token -> {m -> m.os},
  .cs: Token -> {m -> m.cs},
  .oc: Token -> {m -> m.oc},
  .cc: Token -> {m -> m.cc},
  .quote: Token -> {m -> m.quote},
  .comma: Token -> {m -> m.comma},
  .quoted(chars: Str): Token -> {m -> m.quoted(chars)},
  .numeric(chars: Str): Token -> {m -> m.numeric(chars)},
  }
Token: {
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut TokenMatch[R]): R,
  }

_LexerModeMatch: {
  mut .value: R,
  mut .string: R,
  mut .stringEscape: R,
  mut .unicodeEscape: R,
  mut .hex: R,
  mut .digits: R,
  mut .whitespace: R,
  }
_LexerModes: _LexerModeMatch{
  .value -> {m -> m.value},
  .string -> {m -> m.string},
  .stringEscape -> {m -> m.stringEscape},
  .unicodeEscape -> {m -> m.unicodeEscape},
  .hex -> {m -> m.hex},
  .digits -> {m -> m.digits},
  }
_LexeerMode: {.match[R:iso,imm,mut,mutH,read,readH](m: mut _LexerModeMatch[R]): R}

// TODO: This should be part of the string library
_IsNumeric: {#(c: Str): Bool -> "1234567890".flow.any{n -> n == c}}
_IsWhitespace: {#(c: Str): Bool -> Block#
  .assert {c.size == 1}
  .return{(c == " ") || (c == "\n") || (c == "\r") || (c == "\t")}
  }
