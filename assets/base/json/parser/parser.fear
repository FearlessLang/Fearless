package base.json

ParseJson: {#(input: Str): mut Action[Json] -> {res -> Try#{input.flow
  .actor[mut _LexerCtx,Token](_LexerCtxs#, mut LexJson)
  .actor[mut Var[mut _ParserActor],Json](
    Var#[mut _ParserActor](mut _TopLevelParser),
    {downstream, ctx, token -> ctx.get#(downstream, ctx, token)}
    )
//      .value -> token.match(mut _SubMatch[ActorRes]{
//        .mode -> "value", .token -> token,
//        .quoted(str) -> Block#(downstream#(Jsons.string str), ActorRes.continue),
//        .os -> Block#(ctx.set(_ParserCtxs.array), ActorRes.continue),
//        }),
//      .array -> token.match(mut _SubMatch[ActorRes]{
//        .mode -> "array", .token -> token,
//        }),
//      .object -> Todo!"objects",
//      }})
  .first
  }.run{
    .ok(optJson) -> optJson.match{
      .some(json) -> res.ok(json),
      .empty -> res.info(Infos.msg("Empty string found, expected JSON."))
      },
    .info(info) -> res.info(info),
    }
  }}

_ParserActor: {
  mut #(downstream: mut base.flows._Sink[Json], state: mut Var[mut _ParserActor], e: Token): ActorRes
  }
_TopLevelParser: _ParserActor{downstream, behaviour, token -> Block#
  .do {behaviour.set(_ValueParser#({value -> downstream#value}, this))}
  .return {behaviour.get#(downstream, behaviour, token)}
  }
_ValueParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> {'parser
  downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
    .mode -> "value", .token -> token,
    .true -> Block#(collector#(Jsons.bool True), behaviour.set(old), ActorRes.continue),
    .false -> Block#(collector#(Jsons.bool False), behaviour.set(old), ActorRes.continue),
    .null -> Block#(collector#(Jsons.null), behaviour.set(old), ActorRes.continue),
    .quoted(str) -> Block#(collector#(Jsons.string str), behaviour.set(old), ActorRes.continue),
    .os -> Block#(behaviour.set(_ArrayParser#(collector, parser)), ActorRes.continue),
    })
  }}
_ArrayParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> Block#
  .let[mut IsoPod[iso List[Json]]] es = {IsoPod#(List#)}
  .return {{'parser
    downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
      .mode -> "array", .token -> token,
      .cs -> Block#(collector#(Jsons.array(es!)), behaviour.set(old), ActorRes.continue),
      .default(_) -> Block#
        .let[mut Consumer[Json]] collector' = {{value -> es.mutate{es' -> es'.add(value)}!}}
        .return {_ValueParser
          #(collector', _ArrayCommaParser#(collector', parser))
          #(downstream, behaviour, token)},
      })
    }}
  }
_ArrayCommaParser: {#(collector: mut Consumer[Json], old: mut _ParserActor): mut _ParserActor -> {'parser
  downstream, behaviour, token -> token.match(mut _SubMatch[ActorRes]{
    .mode -> "comma or end of array", .token -> token,
    .cs -> old#(downstream, behaviour, token),
    .comma -> Block#(
      behaviour.set(_ValueParser#(collector, parser)),
      ActorRes.continue
      ),
    })}
  }
//_ArrayParser: _ParserActor{downstream, behaviour, token -> token.match(mut _SubMatch{
//  .mode -> "array", .token -> token,
//  .quoted(str) ->
//  })}

TopLevelMatch: {
  #(downstream: mut base.flows._Sink[Json],
    ctx: mut Var[mut Opt[mut _SubMatch[ActorRes]]],
    token: Token
  ): mut _SubMatch[ActorRes] -> {
    .mode -> "value", .token -> Tokens.null(0, 0),
    .quoted(str) -> Block#(downstream#(Jsons.string str), ActorRes.continue),
    .os -> Block#(
      ctx.set(Opts#{
        .mode -> "array", .token -> token,
        }),
      ActorRes.continue
      )
    }}

//_ParserCtxs: {#: mut _ParserCtx -> mut _ParserCtx: {
//
//  }}

// TODO: instead of this, in the context store a "next matcher" as our context.
//_ParserCtxMatch[R:iso,imm,mut,mutH,read,readH]: {
//  mut .value: R,
//  mut .object: R,
//  mut .array: R,
//  }
//_ParserCtxs: {
//  .value: mut _ParserCtx -> {m -> m.value},
//  .object: mut _ParserCtx -> {m -> m.object},
//  .array: mut _ParserCtx -> {m -> m.array},
//  }
//_ParserCtx: {
//  mut .match[R:iso,imm,mut,mutH,read,readH](m: mut _ParserCtxMatch[R]): R,
//  }

_SubMatch[R:iso,imm,mut,mutH,read,readH]: TokenMatch[R]{
  read .mode: Str,
  read .token: Token,
  read .errorSuffix: Str -> mut " at " + (this.token.line.str) + ":" + (this.token.col.str),
  mut .default(kind: Str): R -> Error.msg ("Unexpected " + kind + " when parsing a JSON " + (this.mode) + (this.errorSuffix)),
  .true -> this.default("'true'"),
  .false -> this.default("'false'"),
  .null -> this.default("'null'"),
  .quoted(chars) -> this.default("string \"" + chars + "\""),
  .numeric(chars) -> this.default("number " + chars),
  .os -> this.default("'['"),
  .cs -> this.default("']'"),
  .oc -> this.default("'{'"),
  .cc -> this.default("'}'"),
  .comma -> this.default("','"),
  .colon -> this.default("':'"),
  }
