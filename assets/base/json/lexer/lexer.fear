package base.json

// Strictly follows ECMA-404 https://www.json.org/json-en.html
// and the identical RFC 8259 https://tools.ietf.org/html/rfc8259
LexJson: Actor[mut _LexerCtx,Str,Token]{downstream, ctx, e -> ctx.mode.match{
  .value -> Block#
    .if {ctx.isWhitespace(e)} .return {ActorRes.continue}
    .if {ctx.isEmpty} .return {_LexStartingToken#(downstream, ctx, e)}
    .do {ctx.write(e)}
    .if {ctx.str == "true"} .return {Block#(downstream#(Tokens.true), ctx.clear, ActorRes.continue)}
    .if {ctx.str == "false"} .return {Block#(downstream#(Tokens.false), ctx.clear, ActorRes.continue)}
    .if {ctx.str == "null"} .return {Block#(downstream#(Tokens.null), ctx.clear, ActorRes.continue)}
    .do {downstream#(Tokens.unknownFragment(ctx.str))}
    .return {ActorRes.stop},
  .string -> LexString#(downstream, ctx, e),
  .stringEscape -> LexStringEscapes#(downstream, ctx, e),
  .unicodeEscape(buf) -> LexUnicodeEscapes#(ctx, buf, e),
  .digits -> Todo!"Digits",
  }}

_LexerCtxs: {#: mut _LexerCtx -> Block#
  .let buffer = {mut ""}
  .let mode = {Var#[mut _LexerMode](_LexerModes.value)}
  .let isDigit = {Regexs#"[0-9]"}
  .let isWhitespace = {Regexs#"[ \\n\\r\\t]"}
  .let isChar = {Regexs#"[\\U{0020}-\\U{10FFFF}]"}
  .let unpairedSurrogate = {List.withCapacity[Nat](1)}
  .return {mut _LexerCtx: Stringable{'ctx
    read .isEmpty: Bool -> buffer.isEmpty,
    mut .write(e: Str): Void -> buffer.append(e),
    mut .clear: Void -> buffer.clear,
    .str -> buffer.str,
    mut .mode: mut _LexerMode -> mode.get,
    mut .mode(next: mut _LexerMode): Void -> mode.set(next),
    read .isDigit(ch: Str): Bool -> isDigit.isMatch(ch),
    read .isWhitespace(ch: Str): Bool -> isWhitespace.isMatch(ch),
    read .isChar(ch: Str): Bool -> isChar.isMatch(ch),
    mut .unpairedSurrogate: mut List[Nat] -> unpairedSurrogate,
    }}
  }

_LexStartingToken: Actor[mut _LexerCtx,Str,Token]{downstream, ctx, e -> Block#
  .if {ctx.isDigit(e)}
    .return {Block#(
      ctx.write(e),
      ctx.mode(_LexerModes.digits),
      ActorRes.continue
      )}
  .if {e == "\""} .return {Block#(
    ctx.mode(_LexerModes.string),
    ActorRes.continue
    )}
  .if {e == "["} .return {Block#(downstream#(Tokens.os), ActorRes.continue)}
  .if {e == "]"} .return {Block#(downstream#(Tokens.cs), ActorRes.continue)}
  .if {e == "{"} .return {Block#(downstream#(Tokens.oc), ActorRes.continue)}
  .if {e == "}"} .return {Block#(downstream#(Tokens.cc), ActorRes.continue)}
  .if {e == ","} .return {Block#(downstream#(Tokens.comma), ActorRes.continue)}
  .if {e == ":"} .return {Block#(downstream#(Tokens.colon), ActorRes.continue)}
  .do {ctx.write(e)}
  .return {{}}
  }

TokenMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .true: R,
  mut .false: R,
  mut .null: R,
  mut .quoted(chars: Str): R,
  mut .numeric(chars: Str): R,

  mut .os: R,
  mut .cs: R,
  mut .oc: R,
  mut .cc: R,
  mut .quote: R,
  mut .comma: R,
  mut .colon: R,

  // The error case:
  mut .unknownFragment(bufferContents: Str): R,
  }
Tokens: {
  .true: Token -> {m -> m.true},
  .false: Token -> {m -> m.false},
  .null: Token -> {m -> m.null},
  .os: Token -> {m -> m.os},
  .cs: Token -> {m -> m.cs},
  .oc: Token -> {m -> m.oc},
  .cc: Token -> {m -> m.cc},
  .quote: Token -> {m -> m.quote},
  .comma: Token -> {m -> m.comma},
  .colon: Token -> {m -> m.colon},
  .quoted(chars: Str): Token -> {m -> m.quoted(base.Debug#chars)},
  .numeric(chars: Str): Token -> {m -> m.numeric(chars)},
//  .unknownFragment(bufferContents: Str): Token -> {m -> m.unknownFragment(bufferContents)},
  .unknownFragment(bufferContents: Str): Token -> Error.msg ("Unknown fragment in JSON code:\n" + bufferContents),
  }
Token: {
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut TokenMatch[R]): R,
  }

_LexerModeMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .value: R,
  mut .string: R,
  mut .stringEscape: R,
  mut .unicodeEscape(buffer: mut List[Str]): R,
  mut .digits: R,
  }
_LexerModes: {
  .value: mut _LexerMode -> {m -> m.value},
  .string: mut _LexerMode -> {m -> m.string},
  .stringEscape: mut _LexerMode -> {m -> m.stringEscape},
  .unicodeEscape: mut _LexerMode -> Block#
    .let[mut List[Str]] buffer = {List.withCapacity(4)}
    .return {{m -> m.unicodeEscape(buffer)}},
  .digits: mut _LexerMode -> {m -> m.digits},
  }
_LexerMode: {mut .match[R:iso,imm,mut,mutH,read,readH](m: mut _LexerModeMatch[R]): R}

// TODO: This should be part of the string library
//_IsDigit: {#(c: Str): Bool -> "0123456789".flow.any{n -> n == c}}
_IsWhitespace: {#(c: Str): Bool -> Block#
  .assert {c.size == 1}
  .return{(c == " ") || (c == "\n") || (c == "\r") || (c == "\t")}
  }
