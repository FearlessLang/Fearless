package base.json

// Strictly follows https://www.json.org/json-en.html
ParseJson: {#(input: Str): Json -> input.flow
  .actor[mut _LexerCtx,Token](_LexerCtxs#, {downstream, state, e -> state.mode.match{
    .value -> Block#
       .if {state.isEmpty} .return {_LexStartingToken#(downstream, state, e)}
       .do {state.write(e)}
       .if {state.str == "true"} .return {Block#(downstream#(Tokens.true), state.clear, ActorRes.continue)}
       .if {state.str == "false"} .return {Block#(downstream#(Tokens.false), state.clear, ActorRes.continue)}
       .if {state.str == "null"} .return {Block#(downstream#(Tokens.null), state.clear, ActorRes.continue)}
       .do {downstream#(Tokens.unknownFragment(state.str))}
       .return {ActorRes.stop},
    .string -> LexString#(downstream, state, e),
    .stringEscape -> Todo!,
    .unicodeEscape -> Todo!,
    .hex -> Todo!,
    .digits -> Todo!,
    }

//  Block#
//    .let wasEscaped = {state.isEscaped}
//    .do {state.isEscaped(False)}
//    .do {state.write(e)}
//    .if {(state.str == "\"") && (wasEscaped.not)}
//      .return {Block#
//        .if {state.isStrMode} .do {downstream#(Tokens.quoted(state.str))}
//        .do {state.toggleStrMode}
//        .do {state.clear}
//        .return {ActorRes.continue}
//        }
//    // TODO: check for control characters if in string (should terminate string mode and tokenize as an unknownFragment
//    .if {state.isStrMode} .return {{}}
//    .return {{}}
    })
    .fold(Jsons.null, {acc, _ -> acc})
  }

_LexerCtxs: {#: mut _LexerCtx -> Block#
  .let buffer = {mut ""}
  .let mode = {Var#[_LexerMode](_LexerModes.value)}
  .return {mut _LexerCtx: Stringable{'state
    read .isEmpty: Bool -> buffer.isEmpty,
    mut .write(e: Str): Void -> buffer.append(e),
    mut .clear: Void -> buffer.clear,
    .str -> buffer.str,
    read .mode: _LexerMode -> mode.get,
    mut .mode(next: _LexerMode): Void -> mode.set(next),
    }}
  }

_LexStartingToken: Actor[mut _LexerCtx,Str,Token]{downstream, state, e -> Block#
  .if {_IsDigit#(e)}
    .return {Block#(
      state.write(e),
      state.mode(_LexerModes.digits),
      ActorRes.continue
      )}
  .if {e == "\""} .return {Block#(
    state.mode(_LexerModes.string),
    ActorRes.continue
    )}
  .if {e == "["} .return {Block#(downstream#(Tokens.os), ActorRes.continue)}
  .if {e == "]"} .return {Block#(downstream#(Tokens.cs), ActorRes.continue)}
  .if {e == "{"} .return {Block#(downstream#(Tokens.oc), ActorRes.continue)}
  .if {e == "}"} .return {Block#(downstream#(Tokens.cc), ActorRes.continue)}
  .if {e == ","} .return {Block#(downstream#(Tokens.comma), ActorRes.continue)}
  .do {state.write(e)}
  .return {{}}
  }

TokenMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .true: R,
  mut .false: R,
  mut .null: R,
  mut .quoted(chars: Str): R,
  mut .numeric(chars: Str): R,

  mut .os: R,
  mut .cs: R,
  mut .oc: R,
  mut .cc: R,
  mut .quote: R,
  mut .comma: R,
  mut .colon: R,

  // The error case:
  mut .unknownFragment(bufferContents: Str): R,
  }
Tokens: {
  .true: Token -> {m -> m.true},
  .false: Token -> {m -> m.false},
  .null: Token -> {m -> m.null},
  .os: Token -> {m -> m.os},
  .cs: Token -> {m -> m.cs},
  .oc: Token -> {m -> m.oc},
  .cc: Token -> {m -> m.cc},
  .quote: Token -> {m -> m.quote},
  .comma: Token -> {m -> m.comma},
  .quoted(chars: Str): Token -> {m -> m.quoted(chars)},
  .numeric(chars: Str): Token -> {m -> m.numeric(chars)},
  .unknownFragment(bufferContents: Str): Token -> {m -> m.unknownFragment(bufferContents)},
  }
Token: {
  read .match[R:iso,imm,mut,mutH,read,readH](m: mut TokenMatch[R]): R,
  }

_LexerModeMatch[R:iso,imm,mut,mutH,read,readH]: {
  mut .value: R,
  mut .string: R,
  mut .stringEscape: R,
  mut .unicodeEscape: R,
  mut .hex: R,
  mut .digits: R,
  }
_LexerModes: {
  .value: _LexerMode -> {m -> m.value},
  .string: _LexerMode -> {m -> m.string},
  .stringEscape: _LexerMode -> {m -> m.stringEscape},
  .unicodeEscape: _LexerMode -> {m -> m.unicodeEscape},
  .hex: _LexerMode -> {m -> m.hex},
  .digits: _LexerMode -> {m -> m.digits},
  }
_LexerMode: {.match[R:iso,imm,mut,mutH,read,readH](m: mut _LexerModeMatch[R]): R}

// TODO: This should be part of the string library
_IsDigit: {#(c: Str): Bool -> "0123456789".flow.any{n -> n == c}}
_IsWhitespace: {#(c: Str): Bool -> Block#
  .assert {c.size == 1}
  .return{(c == " ") || (c == "\n") || (c == "\r") || (c == "\t")}
  }
