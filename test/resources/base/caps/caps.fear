package base.caps
alias base.Sealed as Sealed, alias base.Void as Void, alias base.Str as Str,

LentReturnStmt[R]:{ lent #: mdf R }
System[R]:Sealed{
//  lent .use[C](c: CapFactory[lent _RootCap, lent C], cont: mut UseCapCont[C, mdf R]): mdf R -> Block[mdf R]
//    .var[lent C] cap = { c#_RootCap }
//    .var[mdf R] res = { cont#(cap, this) }
//    .do{ c.close(cap) }
//    .return{ res },
  lent .use[C](c: CapFactory[lent _RootCap, lent C], cont: mut UseCapCont[C, mdf R]): mdf R ->
    cont#(c#_RootCap, this), // TODO: use a block here to call c.close afterwards
  // mut .clone(): iso System[mdf R] -> {},
  lent .return(ret: lent LentReturnStmt[mdf R]): mdf R -> ret#
  }

_RootCap:Sealed,IO{
  .print(msg) -> this.print(msg),
  .println(msg) -> this.println(msg),
  }
UseCapCont[C, R]:{ mut #(cap: lent C, self: lent System[mdf R]): mdf R }
CapFactory[C,R]:{
  #(auth: lent C): lent R,
  .close(c: lent R): Void,
  }
IO:{
  lent .print(msg: Str): Void,
  lent .println(msg: Str): Void,
  }
// TODO: I'd like to be able to make this CapFactory[lent IO, lent IO]
IO':CapFactory[lent _RootCap, lent IO]{
  #(auth: lent _RootCap): lent IO -> this.scope(auth),
  .scope(auth: lent IO): lent IO -> auth,
  .close(c: lent IO): Void -> {},
  }