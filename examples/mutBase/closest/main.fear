package closest
Test:Main[Void]{ _,_ -> Do#
  .var[Int] closest = { Closest#(LList[Int] + 35 + 52 + 84 + 14, 49) }
  .return{ Assert#(closest == 52, closest.str, {{}}) }
  }
Closest:{
  #(ns: LList[Int], target: Int): Int -> Do#
    .do{ Assert#(ns.isEmpty.not, "empty list :-(", {{}}) }
    .var[mut Ref[Int]] closest = { Ref#(ns.head!) }
    .do{ mut Closest'{ 'self
      h, t -> h.match{
        .none -> {},
        .some(n) -> (target - n).abs < (target - closest*).abs ? {
          .then -> closest := n,
          .else -> self#(t.head, t.tail)
          }
        }
      }#(ns.head, ns.tail) }
    .return{ closest* }
  }
Closest':{ mut #(h: Opt[Int], t: LList[Int]): Void }
